import { existsSync, mkdirSync, readFileSync, unlinkSync, writeFileSync } from 'node:fs';
import { join } from 'node:path';
import { BadConfigError } from '../errors/bad-config-error.js';
import { getCurrentWorkingDirectory } from './env-service.js';
import logger from '../utils/logger.js';
export const CONFIG_NAME = '.mappsrc';
const ENCODING = 'utf8';
const CONFIG_PROCESS_ENV_DOMAIN = 'MONDAY_CODE';
let configExists = false;
const checkConfigExists = (directoryPath, fileName = CONFIG_NAME) => {
    if (configExists)
        return configExists;
    const filePath = join(directoryPath, fileName);
    configExists = existsSync(filePath);
    return configExists;
};
const checkLocalConfigExists = (fileName = CONFIG_NAME) => {
    const filePath = join(getCurrentWorkingDirectory(), fileName);
    const localConfigExists = existsSync(filePath);
    if (!configExists)
        configExists = localConfigExists;
    return localConfigExists;
};
const camelToUpperSnakeCase = (str) => str.replaceAll(/[A-Z]/g, letter => `_${letter}`).toUpperCase();
const generateConfigKeyInProcessEnv = (configKey) => {
    const keyInSnakeCase = camelToUpperSnakeCase(configKey);
    const configKeyInProcessEnv = `${CONFIG_PROCESS_ENV_DOMAIN}_${keyInSnakeCase}`;
    return configKeyInProcessEnv;
};
const setConfigDataInProcessEnv = (data) => {
    for (const [key, value] of Object.entries(data)) {
        const configKeyInProcessEnv = generateConfigKeyInProcessEnv(key);
        process.env[configKeyInProcessEnv] = value;
    }
};
const readConfig = (directoryPath, fileName = CONFIG_NAME) => {
    if (!checkConfigExists(directoryPath, fileName)) {
        throw new BadConfigError(`the file: ${fileName} is not found in ${directoryPath}`);
    }
    const filePath = join(directoryPath, fileName);
    const stringifiedData = readFileSync(filePath, { encoding: ENCODING });
    const data = JSON.parse(stringifiedData);
    return data;
};
const writeConfig = (data, directoryPath, fileName = CONFIG_NAME) => {
    const filePath = join(directoryPath, fileName);
    const stringifiedData = JSON.stringify(data);
    writeFileSync(filePath, stringifiedData, { encoding: ENCODING });
    return data;
};
export const ConfigService = {
    checkConfigExists,
    checkLocalConfigExists,
    getConfigDataByKey(key) {
        const configKeyInProcessEnv = generateConfigKeyInProcessEnv(key);
        return process.env[configKeyInProcessEnv];
    },
    loadConfigToProcessEnv(directoryPath, fileName = CONFIG_NAME) {
        const data = readConfig(directoryPath, fileName);
        setConfigDataInProcessEnv(data);
        return data;
    },
    removeConfig(directoryPath, fileName = CONFIG_NAME) {
        const filePath = join(directoryPath, fileName);
        if (checkConfigExists(directoryPath, fileName)) {
            unlinkSync(filePath);
            configExists = false;
        }
        return true;
    },
    init(data, directoryPath, options = {}) {
        const fileName = options.fileName || CONFIG_NAME;
        const filePath = join(directoryPath, fileName);
        if (!existsSync(directoryPath)) {
            mkdirSync(directoryPath, { recursive: true });
        }
        try {
            if (!existsSync(filePath)) {
                writeConfig(data, directoryPath, fileName);
            }
            else if (options.override) {
                const configDataToOverride = readConfig(directoryPath, fileName);
                const mergedData = { ...configDataToOverride, ...data };
                writeConfig(mergedData, directoryPath, fileName);
            }
            if (options.setInProcessEnv)
                setConfigDataInProcessEnv(data);
            return data;
        }
        catch (error) {
            logger.debug('An error has occurred while creating .mappsrc config file', error.message);
        }
    },
};
