import * as ngrok from '@ngrok/ngrok';
import { generateTunnelingTokenUrl } from '../consts/urls.js';
import { execute } from './api-service.js';
import { tunnelAuthTokenSchema } from './schemas/push-service-schemas.js';
import { HttpError } from '../types/errors/index.js';
import { HttpMethodTypes } from '../types/services/api-service.js';
import logger from '../utils/logger.js';
import { appsUrlBuilder } from '../utils/urls-builder.js';
function handleError(error, DEBUG_TAG, message) {
    logger.debug(error, DEBUG_TAG);
    if (error instanceof HttpError) {
        throw error;
    }
    throw new Error(message);
}
export const generateTunnelingAuthToken = async (ctx) => {
    const DEBUG_TAG = 'generate_tunneling_auth_token';
    try {
        const baseUrl = generateTunnelingTokenUrl();
        const url = appsUrlBuilder(baseUrl);
        const response = await execute({
            url,
            headers: { Accept: 'application/json' },
            method: HttpMethodTypes.PUT,
            query: {
                appId: ctx.appId,
            },
        }, tunnelAuthTokenSchema);
        ctx.authToken = response.token;
        ctx.tunnelDomain = response.domain;
        return {
            token: response.token,
            domain: response.domain,
        };
    }
    catch (error) {
        handleError(error, DEBUG_TAG, 'Failed to generate tunneling auth token.');
    }
};
export const createTunnelConnection = async (ctx) => {
    const DEBUG_TAG = 'create_tunnel_connection';
    try {
        const forwardingAddress = `http://localhost:${ctx.tunnelPort}`;
        logger.debug(`forwarding address: ${forwardingAddress}`, DEBUG_TAG);
        const session = await new ngrok.SessionBuilder().authtoken(String(ctx.authToken)).connect();
        logger.debug(`session created`, DEBUG_TAG);
        const tunnel = await session.httpEndpoint().domain(String(ctx.tunnelDomain)).forwardsTo(forwardingAddress).listen();
        logger.debug(`tunnel created`, DEBUG_TAG);
        ctx.forwardingAddress = forwardingAddress;
        ctx.tunnel = tunnel;
    }
    catch (error) {
        handleError(error, DEBUG_TAG, 'Failed to create tunnel connection.');
    }
};
export const connectTunnel = async (ctx, task) => {
    const DEBUG_TAG = 'connect_tunnel';
    const forwardingAddress = ctx.forwardingAddress;
    const tunnel = ctx.tunnel;
    try {
        task.output = `Connection established at: ${String(tunnel.url())} --> forwarding traffic to: ${forwardingAddress}
      \nTerminate this process to close the tunnel connection`;
        await tunnel.forward(forwardingAddress); // actually opens the tunnel, and will "hang" open until terminated
    }
    catch (error) {
        handleError(error, DEBUG_TAG, 'Failed to establish tunnel connection.');
    }
};
