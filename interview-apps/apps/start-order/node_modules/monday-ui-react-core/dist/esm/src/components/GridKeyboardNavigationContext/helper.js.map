{"version":3,"file":"helper.js","sources":["../../../../../src/components/GridKeyboardNavigationContext/helper.ts"],"sourcesContent":["import { NavDirections } from \"../../hooks/useFullKeyboardListeners\";\nimport { DirectionMap, DirectionMaps, GridElementRef, Position } from \"./GridKeyboardNavigationContextConstants\";\n\nfunction throwIfCausingCircularDependency(directionMaps: DirectionMaps, newPosition: Position) {\n  const { topElement, bottomElement, leftElement, rightElement } = newPosition;\n  if (topElement && bottomElement) {\n    if (directionMaps[NavDirections.UP].get(topElement) === bottomElement) {\n      throwMessage(\"BOTTOM\", \"TOP\");\n    }\n    if (directionMaps[NavDirections.DOWN].get(bottomElement) === topElement) {\n      throwMessage(\"TOP\", \"BOTTOM\");\n    }\n  }\n  if (leftElement && rightElement) {\n    if (directionMaps[NavDirections.LEFT].get(leftElement) === rightElement) {\n      throwMessage(\"RIGHT\", \"LEFT\");\n    }\n    if (directionMaps[NavDirections.RIGHT].get(rightElement) === leftElement) {\n      throwMessage(\"LEFT\", \"RIGHT\");\n    }\n  }\n\n  function throwMessage(directionFrom: string, directionTo: string) {\n    throw new Error(\n      `Circular positioning detected: the ${directionFrom} element is already positioned to the ${directionTo} of the ${directionTo} element. This probably means the layout isn't ordered correctly.`\n    );\n  }\n}\n\nexport const getDirectionMaps = (positions: Position[]) => {\n  const directionMaps: DirectionMaps = {\n    [NavDirections.RIGHT]: new Map(),\n    [NavDirections.LEFT]: new Map(),\n    [NavDirections.UP]: new Map(),\n    [NavDirections.DOWN]: new Map()\n  };\n  positions.forEach(position => {\n    throwIfCausingCircularDependency(directionMaps, position);\n\n    const { topElement, bottomElement, leftElement, rightElement } = position;\n    if (topElement && bottomElement) {\n      directionMaps[NavDirections.UP].set(bottomElement, topElement);\n      directionMaps[NavDirections.DOWN].set(topElement, bottomElement);\n    }\n    if (leftElement && rightElement) {\n      directionMaps[NavDirections.LEFT].set(rightElement, leftElement);\n      directionMaps[NavDirections.RIGHT].set(leftElement, rightElement);\n    }\n  });\n  return directionMaps;\n};\n\nexport const getOppositeDirection = (direction: NavDirections) => {\n  switch (direction) {\n    case NavDirections.LEFT:\n      return NavDirections.RIGHT;\n    case NavDirections.RIGHT:\n      return NavDirections.LEFT;\n    case NavDirections.UP:\n      return NavDirections.DOWN;\n    case NavDirections.DOWN:\n      return NavDirections.UP;\n    default:\n      throw new Error(`Unexpected direction: ${direction}`);\n  }\n};\n\nexport const getOutmostElementInDirection = (\n  directionMaps: DirectionMaps,\n  direction: NavDirections\n): GridElementRef => {\n  const directionMap = directionMaps[direction];\n  const firstEntry = [...directionMap][0]; // start with any element\n  if (!firstEntry) {\n    // no relations were registered for this direction - fallback to a different direction\n    if ([NavDirections.LEFT, NavDirections.RIGHT].includes(direction)) {\n      // there are no registered horizontal relations registered, try vertical relations. Get the top-most element.\n      return getOutmostElementInDirection(directionMaps, NavDirections.UP);\n    }\n    // there are no registered vertical relations registered, try horizontal relations. Get the left-most element.\n    return getOutmostElementInDirection(directionMaps, NavDirections.LEFT);\n  }\n  const firstRef = firstEntry[0];\n  return getLastFocusableElementFromElementInDirection(directionMap, firstRef);\n};\n\nexport const getNextElementToFocusInDirection = (\n  directionMap: DirectionMap,\n  elementRef: GridElementRef\n): null | GridElementRef => {\n  const next = directionMap.get(elementRef);\n  if (!next) {\n    // this is the last element on the direction map - there' nothing next\n    return null;\n  }\n  if (!next.current || next.current.disabled || next.current.dataset?.disabled === \"true\") {\n    // the next element is not mounted or disabled - try the next one\n    return getNextElementToFocusInDirection(directionMap, next);\n  }\n  return next;\n};\n\nfunction getLastFocusableElementFromElementInDirection(directionMap: DirectionMap, initialRef: GridElementRef) {\n  let done = false;\n  let currentRef = initialRef;\n\n  while (!done) {\n    // as long as there's a mounted element which in that direction, take it.\n    const nextEligible = getNextElementToFocusInDirection(directionMap, currentRef);\n    if (!nextEligible) {\n      done = true;\n    } else {\n      currentRef = nextEligible;\n    }\n  }\n\n  return currentRef;\n}\n"],"names":["getDirectionMaps","positions","directionMaps","_defineProperty","NavDirections","RIGHT","Map","LEFT","UP","DOWN","forEach","position","newPosition","topElement","bottomElement","leftElement","rightElement","throwMessage","directionFrom","directionTo","Error","concat","get","throwIfCausingCircularDependency","set","getOppositeDirection","direction","getOutmostElementInDirection","directionMap","firstEntry","_toConsumableArray","initialRef","done","currentRef","nextEligible","getNextElementToFocusInDirection","getLastFocusableElementFromElementInDirection","includes","elementRef","next","current","disabled","_a","dataset"],"mappings":"mLA6BaA,EAAmB,SAACC,GAC/B,IAAMC,EAAaC,EAAAA,EAAAA,EAAAA,EAAA,GAChBC,EAAcC,MAAQ,IAAIC,KAC1BF,EAAcG,KAAO,IAAID,KACzBF,EAAcI,GAAK,IAAIF,KACvBF,EAAcK,KAAO,IAAIH,KAe5B,OAbAL,EAAUS,SAAQ,SAAAC,IAjCpB,SAA0CT,EAA8BU,GACtE,IAAQC,EAAyDD,EAAzDC,WAAYC,EAA6CF,EAA7CE,cAAeC,EAA8BH,EAA9BG,YAAaC,EAAiBJ,EAAjBI,aAkBhD,SAASC,EAAaC,EAAuBC,GAC3C,MAAUC,MAAKC,sCAAAA,OACyBH,EAAa,0CAAAG,OAAyCF,EAAWE,YAAAA,OAAWF,uEAEtH,CArBIN,GAAcC,IACZZ,EAAcE,EAAcI,IAAIc,IAAIT,KAAgBC,GACtDG,EAAa,SAAU,OAErBf,EAAcE,EAAcK,MAAMa,IAAIR,KAAmBD,GAC3DI,EAAa,MAAO,WAGpBF,GAAeC,IACbd,EAAcE,EAAcG,MAAMe,IAAIP,KAAiBC,GACzDC,EAAa,QAAS,QAEpBf,EAAcE,EAAcC,OAAOiB,IAAIN,KAAkBD,GAC3DE,EAAa,OAAQ,SAS3B,CAUIM,CAAiCrB,EAAeS,GAEhD,IAAQE,EAAyDF,EAAzDE,WAAYC,EAA6CH,EAA7CG,cAAeC,EAA8BJ,EAA9BI,YAAaC,EAAiBL,EAAjBK,aAC5CH,GAAcC,IAChBZ,EAAcE,EAAcI,IAAIgB,IAAIV,EAAeD,GACnDX,EAAcE,EAAcK,MAAMe,IAAIX,EAAYC,IAEhDC,GAAeC,IACjBd,EAAcE,EAAcG,MAAMiB,IAAIR,EAAcD,GACpDb,EAAcE,EAAcC,OAAOmB,IAAIT,EAAaC,GAExD,IACOd,CACT,EAEauB,EAAuB,SAACC,GACnC,OAAQA,GACN,KAAKtB,EAAcG,KACjB,OAAOH,EAAcC,MACvB,KAAKD,EAAcC,MACjB,OAAOD,EAAcG,KACvB,KAAKH,EAAcI,GACjB,OAAOJ,EAAcK,KACvB,KAAKL,EAAcK,KACjB,OAAOL,EAAcI,GACvB,QACE,MAAUY,MAAK,yBAAAC,OAA0BK,IAE/C,EAEaC,EAA+B,SAA/BA,EACXzB,EACAwB,GAEA,IAAME,EAAe1B,EAAcwB,GAC7BG,EAAaC,EAAIF,GAAc,GACrC,OAAKC,EA6BP,SAAuDD,EAA4BG,GACjF,IAAIC,GAAO,EACPC,EAAaF,EAEjB,MAAQC,GAAM,CAEZ,IAAME,EAAeC,EAAiCP,EAAcK,GAC/DC,EAGHD,EAAaC,EAFbF,GAAO,CAIV,CAED,OAAOC,CACT,CAlCSG,CAA8CR,EADpCC,EAAW,IALjBF,EAA6BzB,EAFlC,CAACE,EAAcG,KAAMH,EAAcC,OAAOgC,SAASX,GAEFtB,EAAcI,GAGhBJ,EAAcG,KAIrE,EAEa4B,EAAmC,SAAnCA,EACXP,EACAU,SAEMC,EAAOX,EAAaN,IAAIgB,GAC9B,OAAKC,GAIAA,EAAKC,SAAWD,EAAKC,QAAQC,UAA+C,UAAb,QAAtBC,EAAAH,EAAKC,QAAQG,eAAS,IAAAD,OAAA,EAAAA,EAAAD,UAE3DN,EAAiCP,EAAcW,GAEjDA,EANE,IAOX"}