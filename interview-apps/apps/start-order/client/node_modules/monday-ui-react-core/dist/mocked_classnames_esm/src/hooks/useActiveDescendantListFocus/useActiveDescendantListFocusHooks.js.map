{"version":3,"file":"useActiveDescendantListFocusHooks.js","sources":["../../../../../src/hooks/useActiveDescendantListFocus/useActiveDescendantListFocusHooks.ts"],"sourcesContent":["import React, { MutableRefObject, useCallback, useEffect, useMemo, useRef } from \"react\";\nimport useKeyEvent, { UseKeyEventArgs } from \"../useKeyEvent\";\nimport useEventListener from \"../useEventListener\";\nimport usePrevious from \"../usePrevious\";\nimport { getNextSelectableIndex, getPreviousSelectableIndex } from \"./useActiveDescendantListFocusHelpers\";\nimport useListenFocusTriggers from \"../useListenFocusTriggers\";\n\nenum ArrowDirection {\n  UP = \"ArrowUp\",\n  DOWN = \"ArrowDown\",\n  RIGHT = \"ArrowRight\",\n  LEFT = \"ArrowLeft\"\n}\n\nconst ENTER_KEY = \"Enter\";\nconst SPACE_KEY = \" \";\n\nexport function useSupportArrowsKeyboardNavigation({\n  itemsCount,\n  focusedElementRef,\n  visualFocusItemIndex,\n  setVisualFocusItemIndex,\n  isHorizontalList,\n  isItemSelectable,\n  listenerOptions,\n  triggeredByKeyboard\n}: {\n  itemsCount: number;\n  focusedElementRef: MutableRefObject<HTMLElement>;\n  visualFocusItemIndex: number;\n  setVisualFocusItemIndex: (index: number) => void;\n  isHorizontalList: boolean;\n  isItemSelectable: (index: number) => boolean;\n  triggeredByKeyboard: MutableRefObject<boolean>;\n  listenerOptions: Omit<UseKeyEventArgs, \"keys\" | \"callback\">;\n}) {\n  const nextArrow = isHorizontalList ? ArrowDirection.RIGHT : ArrowDirection.DOWN;\n  const backArrow = isHorizontalList ? ArrowDirection.LEFT : ArrowDirection.UP;\n\n  const onArrowKeyEvent = useCallback(\n    (direction: ArrowDirection) => {\n      // we desire to change the visual focus item only if the user pressed on the keyboard arrows keys while\n      // the focusedElementRef is naturally focus\n      if (document.activeElement !== focusedElementRef.current) {\n        return;\n      }\n\n      // If the focusedElementRef is naturally focus but this is the first keyboard interaction of the user, we will mark future user interactions as trigger by keyboard (until the next mouse interaction)\n      // that from now on the interactions are trigger by keyboard (until the next mouse interaction)\n      if (!triggeredByKeyboard.current) {\n        triggeredByKeyboard.current = true;\n\n        // If the focusedElementRef is naturally focus but this is the first keyboard interaction of the user, we want only to display the item\n        // which right now visually focus without changing it.\n        if (visualFocusItemIndex > -1) {\n          return;\n        }\n      }\n\n      let newIndex;\n\n      // We will change the visual focused item index according to the direction of the pressed arrow\n      if (direction === nextArrow) {\n        newIndex = getNextSelectableIndex({ isItemSelectable, visualFocusItemIndex, itemsCount });\n      } else if (direction === backArrow) {\n        newIndex = getPreviousSelectableIndex({ isItemSelectable, visualFocusItemIndex, itemsCount });\n      }\n\n      if (newIndex > -1 && newIndex !== visualFocusItemIndex) setVisualFocusItemIndex(newIndex);\n    },\n    [\n      focusedElementRef,\n      triggeredByKeyboard,\n      nextArrow,\n      backArrow,\n      visualFocusItemIndex,\n      setVisualFocusItemIndex,\n      isItemSelectable,\n      itemsCount\n    ]\n  );\n  const onArrowBack = useCallback(() => {\n    onArrowKeyEvent(backArrow);\n  }, [backArrow, onArrowKeyEvent]);\n\n  const onArrowNext = useCallback(() => {\n    onArrowKeyEvent(nextArrow);\n  }, [nextArrow, onArrowKeyEvent]);\n\n  useKeyEvent({\n    keys: [nextArrow],\n    callback: onArrowNext,\n    ...listenerOptions\n  });\n\n  useKeyEvent({\n    keys: [backArrow],\n    callback: onArrowBack,\n    ...listenerOptions\n  });\n}\n\nexport function useSupportPressItemKeyboardNavigation({\n  visualFocusItemIndex,\n  focusedElementRef,\n  itemsCount,\n  setVisualFocusItemIndex,\n  onItemClick,\n  isItemSelectable,\n  listenerOptions = undefined,\n  isIgnoreSpaceAsItemSelection = false\n}: {\n  visualFocusItemIndex: number;\n  focusedElementRef: MutableRefObject<HTMLElement>;\n  itemsCount: number;\n  setVisualFocusItemIndex: (index: number) => void;\n  onItemClick: (event: React.MouseEvent | React.KeyboardEvent, index: number) => void;\n  isItemSelectable: (index: number) => boolean;\n  listenerOptions: Omit<UseKeyEventArgs, \"keys\" | \"callback\">;\n  isIgnoreSpaceAsItemSelection: boolean;\n}) {\n  const pressKeys = useMemo(\n    () => (isIgnoreSpaceAsItemSelection ? [ENTER_KEY] : [ENTER_KEY, SPACE_KEY]),\n    [isIgnoreSpaceAsItemSelection]\n  );\n\n  const baseOnClickCallback = useCallback(\n    (event: React.KeyboardEvent, itemIndex: number) => {\n      const hasValidIndex = itemIndex >= 0 && itemIndex < itemsCount;\n      if (!onItemClick || !hasValidIndex || !isItemSelectable(itemIndex)) return;\n      if (visualFocusItemIndex !== itemIndex) setVisualFocusItemIndex(itemIndex);\n      onItemClick(event, itemIndex);\n    },\n    [itemsCount, onItemClick, isItemSelectable, visualFocusItemIndex, setVisualFocusItemIndex]\n  );\n\n  const keyboardOnSelectCallback = useCallback(\n    (event: React.KeyboardEvent) => {\n      // we desire to change the trigger the active item on click callback only if the user pressed on the keyboard arrows keys while\n      // the focusedElementRef is naturally focus\n      if (focusedElementRef.current.contains(document.activeElement)) {\n        baseOnClickCallback(event, visualFocusItemIndex);\n      }\n    },\n    [baseOnClickCallback, focusedElementRef, visualFocusItemIndex]\n  );\n\n  useKeyEvent({\n    keys: pressKeys,\n    callback: keyboardOnSelectCallback,\n    ...listenerOptions\n  });\n}\n\nexport function useCleanVisualFocusOnBlur({\n  focusedElementRef,\n  visualFocusItemIndex,\n  setVisualFocusItemIndex\n}: {\n  focusedElementRef: MutableRefObject<HTMLElement>;\n  visualFocusItemIndex: number;\n  setVisualFocusItemIndex: (index: number) => void;\n}) {\n  const previousFocusedElementRef = usePrevious(focusedElementRef);\n\n  const onBlurCallback = useCallback(() => {\n    if (visualFocusItemIndex !== -1) {\n      setVisualFocusItemIndex(-1);\n    }\n  }, [setVisualFocusItemIndex, visualFocusItemIndex]);\n\n  // if element unmount act like element got blur event\n  useEffect(() => {\n    // if element unmount\n    if (focusedElementRef?.current === null && previousFocusedElementRef?.current !== null) {\n      onBlurCallback();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [focusedElementRef.current, previousFocusedElementRef, onBlurCallback]);\n\n  useEventListener({\n    eventName: \"blur\",\n    ref: focusedElementRef,\n    callback: onBlurCallback\n  });\n}\n\nexport function useSetDefaultItemOnFocusEvent({\n  focusedElementRef,\n  isItemSelectable,\n  visualFocusItemIndex,\n  setVisualFocusItemIndex,\n  itemsCount,\n  defaultVisualFocusItemIndex = -1\n}: {\n  focusedElementRef: MutableRefObject<HTMLElement>;\n  isItemSelectable: (index: number) => boolean;\n  visualFocusItemIndex: number;\n  setVisualFocusItemIndex: (index: number) => void;\n  itemsCount: number;\n  defaultVisualFocusItemIndex: number;\n}) {\n  const triggeredByKeyboard = useRef(false);\n\n  const onFocusByKeyboard = useCallback(() => {\n    triggeredByKeyboard.current = true;\n    if (visualFocusItemIndex !== defaultVisualFocusItemIndex) {\n      let newVisualFocusIndex;\n      if (isItemSelectable(defaultVisualFocusItemIndex)) {\n        newVisualFocusIndex = defaultVisualFocusItemIndex;\n      } else {\n        newVisualFocusIndex = getNextSelectableIndex({\n          isItemSelectable,\n          itemsCount,\n          visualFocusItemIndex: defaultVisualFocusItemIndex\n        });\n      }\n      setVisualFocusItemIndex(newVisualFocusIndex);\n    }\n  }, [\n    defaultVisualFocusItemIndex,\n    isItemSelectable,\n    itemsCount,\n    setVisualFocusItemIndex,\n    triggeredByKeyboard,\n    visualFocusItemIndex\n  ]);\n  const onFocusByMouse = useCallback(() => {\n    triggeredByKeyboard.current = false;\n  }, [triggeredByKeyboard]);\n  useListenFocusTriggers({ ref: focusedElementRef, onFocusByKeyboard, onFocusByMouse });\n\n  return { triggeredByKeyboard };\n}\n\nexport function useKeepFocusOnItemWhenListChanged({\n  visualFocusItemIndex,\n  itemsIds,\n  isItemSelectable,\n  setVisualFocusItemIndex\n}: {\n  visualFocusItemIndex: number;\n  itemsIds: string[];\n  isItemSelectable: (index: number) => boolean;\n  setVisualFocusItemIndex: (index: number) => void;\n}) {\n  const prevItemIds = usePrevious(itemsIds);\n\n  // When item list changed, keep the focus on the same item\n  useEffect(() => {\n    // When the list is changing the index of the focused item is point to a different item then before and\n    // this is why we want to search for the new index of the item and change the index to point to it.\n    let overrideIndexAfterListChanged;\n    const isListChanged = prevItemIds !== undefined && prevItemIds !== itemsIds;\n    if (isListChanged && prevItemIds !== undefined && visualFocusItemIndex !== -1) {\n      const focusedItemId = prevItemIds[visualFocusItemIndex];\n      overrideIndexAfterListChanged = itemsIds.indexOf(focusedItemId);\n    } else {\n      overrideIndexAfterListChanged = visualFocusItemIndex;\n    }\n\n    if (overrideIndexAfterListChanged !== visualFocusItemIndex) {\n      if (isItemSelectable(overrideIndexAfterListChanged)) {\n        setVisualFocusItemIndex(overrideIndexAfterListChanged);\n      } else {\n        const closestSelectableIndex = getNextSelectableIndex({\n          isItemSelectable,\n          visualFocusItemIndex: overrideIndexAfterListChanged,\n          itemsCount: itemsIds.length\n        });\n        setVisualFocusItemIndex(closestSelectableIndex);\n      }\n    }\n  }, [visualFocusItemIndex, itemsIds, isItemSelectable, setVisualFocusItemIndex, prevItemIds]);\n}\n"],"names":["ArrowDirection","ENTER_KEY","useSupportArrowsKeyboardNavigation","_ref","itemsCount","focusedElementRef","visualFocusItemIndex","setVisualFocusItemIndex","isHorizontalList","isItemSelectable","listenerOptions","triggeredByKeyboard","nextArrow","RIGHT","DOWN","backArrow","LEFT","UP","onArrowKeyEvent","useCallback","direction","newIndex","document","activeElement","current","getNextSelectableIndex","getPreviousSelectableIndex","onArrowBack","onArrowNext","useKeyEvent","Object","assign","keys","callback","useSupportPressItemKeyboardNavigation","_ref2","onItemClick","_ref2$listenerOptions","undefined","_ref2$isIgnoreSpaceAs","isIgnoreSpaceAsItemSelection","pressKeys","useMemo","baseOnClickCallback","event","itemIndex","keyboardOnSelectCallback","contains","useCleanVisualFocusOnBlur","_ref3","previousFocusedElementRef","usePrevious","onBlurCallback","useEffect","useEventListener","eventName","ref","useSetDefaultItemOnFocusEvent","_ref4","_ref4$defaultVisualFo","defaultVisualFocusItemIndex","useRef","onFocusByKeyboard","newVisualFocusIndex","onFocusByMouse","useListenFocusTriggers","useKeepFocusOnItemWhenListChanged","_ref5","itemsIds","prevItemIds","overrideIndexAfterListChanged","indexOf","closestSelectableIndex","length"],"mappings":"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"}