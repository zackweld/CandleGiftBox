{"version":3,"file":"VirtualizedList.js","sources":["../../../../../src/components/VirtualizedList/VirtualizedList.tsx"],"sourcesContent":["import cx from \"classnames\";\nimport React, {\n  CSSProperties,\n  ForwardedRef,\n  forwardRef,\n  LegacyRef,\n  ReactElement,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState\n} from \"react\";\nimport { noop as NOOP } from \"lodash-es\";\nimport {\n  Layout,\n  ScrollDirection,\n  VariableSizeList as List,\n  ListOnItemsRenderedProps,\n  ListChildComponentProps,\n  VariableSizeList\n} from \"react-window\";\nimport AutoSizer from \"react-virtualized-auto-sizer\";\nimport usePrevious from \"../../hooks/usePrevious\";\nimport useThrottledCallback from \"../../hooks/useThrottledCallback\";\nimport useMergeRef from \"../../hooks/useMergeRef\";\nimport {\n  easeInOutQuint,\n  getMaxOffset,\n  getNormalizedItems,\n  getOnItemsRenderedData,\n  isLayoutDirectionScrollbarVisible\n} from \"../../services/virtualized-service\";\nimport { getTestId } from \"../../tests/test-ids-utils\";\nimport { ComponentDefaultTestId } from \"../../tests/constants\";\nimport VibeComponentProps from \"src/types/VibeComponentProps\";\nimport VibeComponent from \"../../types/VibeComponent\";\nimport styles from \"./VirtualizedList.module.scss\";\n\nexport type VirtualizedListItem = {\n  value?: string | Record<string, unknown>;\n  height?: number;\n  width?: number;\n  id?: string;\n  offsetTop?: number;\n};\n\nexport interface VirtualizedListProps extends VibeComponentProps {\n  /**\n   * class name to add to the component scrollable container\n   */\n  scrollableClassName?: string;\n  /**\n   * Layout/orientation of the list.\n   * Acceptable values are:\n   * - \"vertical\" (default) - Up/down scrolling.\n   * - \"horizontal\" - Left/right scrolling.\n   */\n  layout?: Layout;\n  /**\n   * A list of items to be rendered\n   */\n  items: VirtualizedListItem[];\n  /**\n   * Will return the element which represent an item in the virtualized list.\n   * Returns `JSX.Element`\n   * @param item - item data\n   * @param _index - item index\n   * @param style - item style, must be injected to the item element wrapper for correct presentation of the item\n   */\n  itemRenderer: (item: VirtualizedListItem, index: number, style: CSSProperties) => ReactElement | JSX.Element;\n  /**\n   * Deprecated - use getItemSize\n   * in order to calculate the number of items to render, the component needs the height of the items\n   * return `number`\n   */\n  getItemHeight?: (item: VirtualizedListItem, index: number) => number;\n  /**\n   * in order to calculate the number of items to render, the component needs the width/height of the items (according to layout)\n   * return `number`\n   */\n  getItemSize?: (item: VirtualizedListItem, index: number) => number;\n  /**\n   * returns Id of an items\n   * returns `string`\n   */\n  getItemId?: (item: VirtualizedListItem, index: number) => string;\n  /**\n   * callback to be called when the scroll is finished\n   */\n  onScrollToFinished?: () => void;\n  /**\n   * number of items to render (below/above the fold)\n   */\n  overscanCount?: number;\n  /**\n   * the speed of the scroll (in ms)\n   */\n  scrollDuration?: number;\n  /**\n   * a callback that is being called when the items are rendered\n   */\n  onItemsRendered?: ({\n    firstItemId,\n    secondItemId,\n    lastItemId,\n    centerItemId,\n    firstItemOffsetEnd,\n    currentOffsetTop\n  }: {\n    firstItemId: string;\n    secondItemId: string;\n    lastItemId: string;\n    centerItemId: string;\n    firstItemOffsetEnd: number;\n    currentOffsetTop: number;\n  }) => void;\n  onItemsRenderedThrottleMs?: number;\n  /**\n   * when the list size changes - `=> (width, height)`\n   */\n  onSizeUpdate?: (width: number, height: number) => void;\n  /**\n   * Deprecated - use onLayoutDirectionScrollbarVisibilityChange\n   */\n  onVerticalScrollbarVisiblityChange?: (value: boolean) => void;\n  /**\n   * Callback - called when the vertical/horizontal (depends on layout) scrollbar visibility changed\n   */\n  onLayoutDirectionScrollbarVisibilityChange?: (value: boolean) => void;\n  role?: string;\n  /** Custom style to pass to the component */\n  style?: CSSProperties;\n  /**\n   * index of the item to scroll to\n   */\n  scrollToId?: string;\n  virtualListRef?: ForwardedRef<HTMLElement>;\n  onScroll?: (horizontalScrollDirection: ScrollDirection, scrollTop: number, scrollUpdateWasRequested: boolean) => void;\n}\n\nconst VirtualizedList: VibeComponent<VirtualizedListProps> = forwardRef(\n  (\n    {\n      className,\n      id,\n      items = [],\n      itemRenderer = (item: VirtualizedListItem, _index: number, _style: CSSProperties) => item,\n      getItemHeight = (item: VirtualizedListItem, _index: number) => item.height,\n      getItemSize = null, // must be null for backward compatibility\n      layout = \"vertical\",\n      onScroll,\n      overscanCount = 0,\n      getItemId = (item: VirtualizedListItem, _index: number) => item.id,\n      scrollToId,\n      scrollDuration = 200,\n      onScrollToFinished = NOOP,\n      onItemsRendered,\n      onItemsRenderedThrottleMs = 200,\n      onSizeUpdate = NOOP,\n      onVerticalScrollbarVisiblityChange = null,\n      onLayoutDirectionScrollbarVisibilityChange = null,\n      virtualListRef,\n      scrollableClassName,\n      role,\n      style,\n      \"data-testid\": dataTestId\n    },\n    ref\n  ) => {\n    // states\n    const [listHeight, setListHeight] = useState(0);\n    const [listWidth, setListWidth] = useState(0);\n\n    const isVerticalList = layout !== \"horizontal\";\n    const listSizeByLayout = useMemo(() => {\n      return isVerticalList ? listHeight : listWidth;\n    }, [isVerticalList, listHeight, listWidth]);\n\n    // prevs\n    const prevScrollToId = usePrevious(scrollToId);\n\n    // Refs\n    const componentRef = useRef(null);\n    const isVerticalScrollbarVisibleRef = useRef(null);\n    const listRef = useRef(null);\n    const scrollTopRef = useRef(0);\n    const animationDataRef = useRef({\n      initialized: false,\n      scrollOffsetInitial: 0,\n      scrollOffsetFinal: 0,\n      animationStartTime: 0\n    });\n    const mergedRef = useMergeRef(ref, componentRef);\n    const mergedListRef = useMergeRef(virtualListRef, listRef);\n\n    const animationData = animationDataRef.current;\n    if (!animationData.initialized) {\n      animationData.initialized = true;\n      animationData.scrollOffsetInitial = 0;\n      animationData.scrollOffsetFinal = 0;\n      animationData.animationStartTime = 0;\n    }\n\n    // Callbacks\n    const sizeGetter = useCallback(\n      (item: VirtualizedListItem, index: number) => {\n        const getSize = getItemSize || getItemHeight;\n        const height = getSize(item, index);\n        if (height === undefined) {\n          console.error(\"Couldn't get height for item: \", item);\n        }\n        return height;\n      },\n      [getItemHeight, getItemSize]\n    );\n\n    const idGetter = useCallback(\n      (item: VirtualizedListItem, index: number) => {\n        const itemId = getItemId(item, index);\n        if (itemId === undefined) {\n          console.error(\"Couldn't get id for item: \", item);\n        }\n        return itemId;\n      },\n      [getItemId]\n    );\n\n    // Memos\n    // Creates object of itemId => { item, index, size, offsetTop}\n    const normalizedItems = useMemo(() => {\n      return getNormalizedItems(items, idGetter, sizeGetter);\n    }, [items, idGetter, sizeGetter]);\n\n    const maxListOffset = useMemo(() => {\n      return getMaxOffset(listSizeByLayout, normalizedItems);\n    }, [listSizeByLayout, normalizedItems]);\n\n    // Callbacks\n    const onScrollCB = useCallback(\n      ({\n        scrollDirection,\n        scrollOffset,\n        scrollUpdateWasRequested\n      }: {\n        scrollDirection: ScrollDirection;\n        scrollOffset: number;\n        scrollUpdateWasRequested: boolean;\n      }) => {\n        scrollTopRef.current = scrollOffset;\n        if (!scrollUpdateWasRequested) {\n          animationData.scrollOffsetInitial = scrollOffset;\n        }\n        onScroll && onScroll(scrollDirection, scrollOffset, scrollUpdateWasRequested);\n      },\n      [onScroll, scrollTopRef, animationData]\n    );\n\n    const animateScroll = useCallback(() => {\n      requestAnimationFrame(() => {\n        const now = performance.now();\n        const ellapsed = now - animationData.animationStartTime;\n        const scrollDelta = animationData.scrollOffsetFinal - animationData.scrollOffsetInitial;\n        const easedTime = easeInOutQuint(Math.min(1, ellapsed / scrollDuration));\n        const scrollOffset = animationData.scrollOffsetInitial + scrollDelta * easedTime;\n        const finalOffsetValue = Math.min(maxListOffset, scrollOffset);\n        scrollTopRef.current = finalOffsetValue;\n        listRef.current?.scrollTo(finalOffsetValue);\n\n        if (ellapsed < scrollDuration) {\n          animateScroll();\n        } else {\n          animationData.animationStartTime = undefined;\n          onScrollToFinished && onScrollToFinished();\n        }\n      });\n    }, [scrollDuration, animationData, listRef, maxListOffset, onScrollToFinished]);\n\n    const startScrollAnimation = useCallback(\n      (item: VirtualizedListItem) => {\n        const { offsetTop } = item;\n        if (animationData.animationStartTime) {\n          // animation already in progress\n          animationData.scrollOffsetFinal = offsetTop;\n          return;\n        }\n        if (animationData.scrollOffsetInitial === offsetTop) {\n          // offset already equals to item offset\n          onScrollToFinished && onScrollToFinished();\n          return;\n        }\n\n        animationData.scrollOffsetFinal = offsetTop;\n        animationData.animationStartTime = performance.now();\n        animateScroll();\n      },\n      [animationData, animateScroll, onScrollToFinished]\n    );\n\n    const rowRenderer = useCallback(\n      ({ index, style }: { index: number; style: CSSProperties }) => {\n        const item = items[index];\n        return itemRenderer(item, index, style);\n      },\n      [items, itemRenderer]\n    );\n\n    const calcItemSize = useCallback(\n      (index: number) => {\n        const item = items[index];\n        return sizeGetter(item, index);\n      },\n      [items, sizeGetter]\n    );\n\n    const updateListSize = useCallback(\n      (width: number, height: number) => {\n        if (height !== listHeight || width !== listWidth) {\n          setTimeout(() => {\n            setListHeight(height);\n            setListWidth(width);\n            onSizeUpdate(width, height);\n          }, 0);\n        }\n      },\n      [listHeight, listWidth, onSizeUpdate]\n    );\n\n    const onItemsRenderedCB = useThrottledCallback(\n      ({ visibleStartIndex, visibleStopIndex }: ListOnItemsRenderedProps) => {\n        if (!onItemsRendered) return;\n        const data = getOnItemsRenderedData(\n          items,\n          normalizedItems,\n          idGetter,\n          visibleStartIndex,\n          visibleStopIndex,\n          listSizeByLayout,\n          scrollTopRef.current\n        );\n        onItemsRendered(data);\n      },\n      { wait: onItemsRenderedThrottleMs, trailing: true },\n      [onItemsRendered, items, normalizedItems, idGetter, listSizeByLayout]\n    );\n\n    // Effects\n    useEffect(() => {\n      // scroll to specific item\n      if (scrollToId && prevScrollToId !== scrollToId) {\n        const hasScrollbar = isLayoutDirectionScrollbarVisible(items, normalizedItems, idGetter, listSizeByLayout);\n        const item = normalizedItems[scrollToId as keyof typeof normalizedItems];\n        hasScrollbar && item && startScrollAnimation(item);\n      }\n    }, [prevScrollToId, scrollToId, startScrollAnimation, normalizedItems, items, idGetter, listSizeByLayout]);\n\n    useEffect(() => {\n      // recalculate row heights\n      if (listRef.current) {\n        listRef.current.resetAfterIndex(0);\n      }\n    }, [normalizedItems]);\n\n    useEffect(() => {\n      // update vertical scrollbar visibility\n      const callback = onLayoutDirectionScrollbarVisibilityChange || onVerticalScrollbarVisiblityChange;\n      if (callback) {\n        const isVisible = isLayoutDirectionScrollbarVisible(items, normalizedItems, idGetter, listSizeByLayout);\n        if (isVerticalScrollbarVisibleRef.current !== isVisible) {\n          isVerticalScrollbarVisibleRef.current = isVisible;\n          callback(isVisible);\n        }\n      }\n    }, [\n      onLayoutDirectionScrollbarVisibilityChange,\n      onVerticalScrollbarVisiblityChange,\n      items,\n      normalizedItems,\n      listSizeByLayout,\n      idGetter\n    ]);\n\n    return (\n      <div\n        ref={mergedRef}\n        className={cx(styles.virtualizedListWrapper, className)}\n        id={id}\n        role={role}\n        data-testid={dataTestId || getTestId(ComponentDefaultTestId.VIRTUALIZED_LIST, id)}\n        style={style}\n      >\n        <AutoSizer>\n          {({ height, width }: { height: number; width: number }) => {\n            updateListSize(width, height);\n            return (\n              <List\n                ref={mergedListRef as unknown as LegacyRef<VariableSizeList<unknown>>}\n                height={height}\n                width={width}\n                itemCount={items.length}\n                itemSize={calcItemSize}\n                onScroll={onScrollCB}\n                layout={layout}\n                overscanCount={overscanCount}\n                onItemsRendered={onItemsRenderedCB}\n                className={scrollableClassName}\n              >\n                {rowRenderer as VibeComponent<ListChildComponentProps>}\n              </List>\n            );\n          }}\n        </AutoSizer>\n      </div>\n    );\n  }\n);\n\nexport default VirtualizedList;\n"],"names":["VirtualizedList","forwardRef","_ref","ref","className","id","_ref$items","items","_ref$itemRenderer","itemRenderer","item","_index","_style","_ref$getItemHeight","getItemHeight","height","_ref$getItemSize","getItemSize","_ref$layout","layout","onScroll","_ref$overscanCount","overscanCount","_ref$getItemId","getItemId","scrollToId","_ref$scrollDuration","scrollDuration","_ref$onScrollToFinish","onScrollToFinished","NOOP","onItemsRendered","_ref$onItemsRenderedT","onItemsRenderedThrottleMs","_ref$onSizeUpdate","onSizeUpdate","_ref$onVerticalScroll","onVerticalScrollbarVisiblityChange","_ref$onLayoutDirectio","onLayoutDirectionScrollbarVisibilityChange","virtualListRef","scrollableClassName","role","style","dataTestId","_useState","useState","_useState2","_slicedToArray","listHeight","setListHeight","_useState3","_useState4","listWidth","setListWidth","isVerticalList","listSizeByLayout","useMemo","prevScrollToId","usePrevious","componentRef","useRef","isVerticalScrollbarVisibleRef","listRef","scrollTopRef","animationDataRef","initialized","scrollOffsetInitial","scrollOffsetFinal","animationStartTime","mergedRef","useMergeRef","mergedListRef","animationData","current","sizeGetter","useCallback","index","undefined","console","error","idGetter","itemId","normalizedItems","getNormalizedItems","maxListOffset","getMaxOffset","onScrollCB","_ref2","scrollDirection","scrollOffset","scrollUpdateWasRequested","animateScroll","requestAnimationFrame","ellapsed","performance","now","scrollDelta","easedTime","easeInOutQuint","Math","min","finalOffsetValue","_a","scrollTo","startScrollAnimation","offsetTop","rowRenderer","_ref3","calcItemSize","updateListSize","width","setTimeout","onItemsRenderedCB","useThrottledCallback","_ref4","data","getOnItemsRenderedData","visibleStartIndex","visibleStopIndex","wait","trailing","useEffect","hasScrollbar","isLayoutDirectionScrollbarVisible","resetAfterIndex","callback","isVisible","React","createElement","cx","styles","virtualizedListWrapper","getTestId","ComponentDefaultTestId","VIRTUALIZED_LIST","AutoSizer","_ref5","List","itemCount","length","itemSize"],"mappings":"yzBA6IMA,IAAAA,EAAuDC,GAC3D,SAAAC,EA0BEC,GACE,IAzBAC,EAASF,EAATE,UACAC,EAAEH,EAAFG,GAAEC,EAAAJ,EACFK,MAAAA,OAAQ,IAAHD,EAAG,GAAEA,EAAAE,EAAAN,EACVO,aAAAA,OAAe,IAAHD,EAAG,SAACE,EAA2BC,EAAgBC,GAAqB,OAAKF,CAAI,EAAAF,EAAAK,EAAAX,EACzFY,cAAAA,OAAa,IAAAD,EAAG,SAACH,EAA2BC,GAAc,OAAKD,EAAKK,MAAM,EAAAF,EAAAG,EAAAd,EAC1Ee,YAAAA,OAAc,IAAHD,EAAG,KAAIA,EAAAE,EAAAhB,EAClBiB,OAAAA,OAAS,IAAHD,EAAG,WAAUA,EACnBE,EAAQlB,EAARkB,SAAQC,EAAAnB,EACRoB,cAAAA,OAAgB,IAAHD,EAAG,EAACA,EAAAE,EAAArB,EACjBsB,UAAAA,OAAS,IAAAD,EAAG,SAACb,EAA2BC,GAAc,OAAKD,EAAKL,EAAE,EAAAkB,EAClEE,EAAUvB,EAAVuB,WAAUC,EAAAxB,EACVyB,eAAAA,OAAiB,IAAHD,EAAG,IAAGA,EAAAE,EAAA1B,EACpB2B,mBAAAA,OAAqBC,IAAHF,EAAGE,EAAIF,EACzBG,EAAe7B,EAAf6B,gBAAeC,EAAA9B,EACf+B,0BAAAA,OAA4B,IAAHD,EAAG,IAAGA,EAAAE,EAAAhC,EAC/BiC,aAAAA,OAAeL,IAAHI,EAAGJ,EAAII,EAAAE,EAAAlC,EACnBmC,mCAAAA,OAAqC,IAAHD,EAAG,KAAIA,EAAAE,EAAApC,EACzCqC,2CAAAA,QAA6C,IAAHD,EAAG,KAAIA,EACjDE,GAActC,EAAdsC,eACAC,GAAmBvC,EAAnBuC,oBACAC,GAAIxC,EAAJwC,KACAC,GAAKzC,EAALyC,MACeC,GAAU1C,EAAzB,eAKF2C,GAAoCC,EAAS,GAAEC,GAAAC,EAAAH,GAAA,GAAxCI,GAAUF,GAAA,GAAEG,GAAaH,GAAA,GAChCI,GAAkCL,EAAS,GAAEM,GAAAJ,EAAAG,GAAA,GAAtCE,GAASD,GAAA,GAAEE,GAAYF,GAAA,GAExBG,GAA4B,eAAXpC,EACjBqC,GAAmBC,GAAQ,WAC/B,OAAOF,GAAiBN,GAAaI,EACtC,GAAE,CAACE,GAAgBN,GAAYI,KAG1BK,GAAiBC,EAAYlC,GAG7BmC,GAAeC,EAAO,MACtBC,GAAgCD,EAAO,MACvCE,GAAUF,EAAO,MACjBG,GAAeH,EAAO,GACtBI,GAAmBJ,EAAO,CAC9BK,aAAa,EACbC,oBAAqB,EACrBC,kBAAmB,EACnBC,mBAAoB,IAEhBC,GAAYC,EAAYpE,EAAKyD,IAC7BY,GAAgBD,EAAY/B,GAAgBuB,IAE5CU,GAAgBR,GAAiBS,QAClCD,GAAcP,cACjBO,GAAcP,aAAc,EAC5BO,GAAcN,oBAAsB,EACpCM,GAAcL,kBAAoB,EAClCK,GAAcJ,mBAAqB,GAIrC,IAAMM,GAAaC,GACjB,SAAClE,EAA2BmE,GAC1B,IACM9D,GADUE,GAAeH,GACRJ,EAAMmE,GAI7B,YAHeC,IAAX/D,GACFgE,QAAQC,MAAM,iCAAkCtE,GAE3CK,CACT,GACA,CAACD,EAAeG,IAGZgE,GAAWL,GACf,SAAClE,EAA2BmE,GAC1B,IAAMK,EAAS1D,EAAUd,EAAMmE,GAI/B,YAHeC,IAAXI,GACFH,QAAQC,MAAM,6BAA8BtE,GAEvCwE,CACT,GACA,CAAC1D,IAKG2D,GAAkB1B,GAAQ,WAC9B,OAAO2B,EAAmB7E,EAAO0E,GAAUN,GAC5C,GAAE,CAACpE,EAAO0E,GAAUN,KAEfU,GAAgB5B,GAAQ,WAC5B,OAAO6B,EAAa9B,GAAkB2B,GACxC,GAAG,CAAC3B,GAAkB2B,KAGhBI,GAAaX,GACjB,SAAAY,GAQK,IAPHC,EAAeD,EAAfC,gBACAC,EAAYF,EAAZE,aACAC,EAAwBH,EAAxBG,yBAMA3B,GAAaU,QAAUgB,EAClBC,IACHlB,GAAcN,oBAAsBuB,GAEtCtE,GAAYA,EAASqE,EAAiBC,EAAcC,EACrD,GACD,CAACvE,EAAU4C,GAAcS,KAGrBmB,GAAgBhB,GAAY,WAChCiB,uBAAsB,iBAEdC,EADMC,YAAYC,MACDvB,GAAcJ,mBAC/B4B,EAAcxB,GAAcL,kBAAoBK,GAAcN,oBAC9D+B,EAAYC,EAAeC,KAAKC,IAAI,EAAGP,EAAWnE,IAElD2E,EAAmBF,KAAKC,IAAIhB,GADbZ,GAAcN,oBAAsB8B,EAAcC,GAEvElC,GAAaU,QAAU4B,EACR,QAAfC,EAAAxC,GAAQW,eAAO,IAAA6B,GAAAA,EAAEC,SAASF,GAEX3E,EAAXmE,EACFF,MAEAnB,GAAcJ,wBAAqBS,EACnCjD,GAAsBA,IAE1B,GACF,GAAG,CAACF,EAAgB8C,GAAeV,GAASsB,GAAexD,IAErD4E,GAAuB7B,GAC3B,SAAClE,GACC,IAAQgG,EAAchG,EAAdgG,UACJjC,GAAcJ,mBAEhBI,GAAcL,kBAAoBsC,EAGhCjC,GAAcN,sBAAwBuC,GAM1CjC,GAAcL,kBAAoBsC,EAClCjC,GAAcJ,mBAAqB0B,YAAYC,MAC/CJ,MANE/D,GAAsBA,GAOzB,GACD,CAAC4C,GAAemB,GAAe/D,IAG3B8E,GAAc/B,GAClB,SAAAgC,GAA8D,IAA3D/B,EAAK+B,EAAL/B,MAED,OAAOpE,EADMF,EAAMsE,GACOA,EAFb+B,EAALjE,MAGV,GACA,CAACpC,EAAOE,IAGJoG,GAAejC,GACnB,SAACC,GAEC,OAAOF,GADMpE,EAAMsE,GACKA,EAC1B,GACA,CAACtE,EAAOoE,KAGJmC,GAAiBlC,GACrB,SAACmC,EAAehG,GACVA,IAAWkC,IAAc8D,IAAU1D,IACrC2D,YAAW,WACT9D,GAAcnC,GACduC,GAAayD,GACb5E,EAAa4E,EAAOhG,EACrB,GAAE,EAEN,GACD,CAACkC,GAAYI,GAAWlB,IAGpB8E,GAAoBC,GACxB,SAAAC,GACE,GAAKpF,EAAL,CACA,IAAMqF,EAAOC,EACX9G,EACA4E,GACAF,GALgBkC,EAAjBG,kBAAmCH,EAAhBI,iBAQlB/D,GACAQ,GAAaU,SAEf3C,EAAgBqF,EAVM,CAWxB,GACA,CAAEI,KAAMvF,EAA2BwF,UAAU,GAC7C,CAAC1F,EAAiBxB,EAAO4E,GAAiBF,GAAUzB,KAuCtD,OAnCAkE,GAAU,WAER,GAAIjG,GAAciC,KAAmBjC,EAAY,CAC/C,IAAMkG,EAAeC,EAAkCrH,EAAO4E,GAAiBF,GAAUzB,IACnF9C,EAAOyE,GAAgB1D,GAC7BkG,GAAgBjH,GAAQ+F,GAAqB/F,EAC9C,CACH,GAAG,CAACgD,GAAgBjC,EAAYgF,GAAsBtB,GAAiB5E,EAAO0E,GAAUzB,KAExFkE,GAAU,WAEJ3D,GAAQW,SACVX,GAAQW,QAAQmD,gBAAgB,EAEpC,GAAG,CAAC1C,KAEJuC,GAAU,WAER,IAAMI,EAAWvF,IAA8CF,EAC/D,GAAIyF,EAAU,CACZ,IAAMC,EAAYH,EAAkCrH,EAAO4E,GAAiBF,GAAUzB,IAClFM,GAA8BY,UAAYqD,IAC5CjE,GAA8BY,QAAUqD,EACxCD,EAASC,GAEZ,CACH,GAAG,CACDxF,GACAF,EACA9B,EACA4E,GACA3B,GACAyB,KAIA+C,EACEC,cAAA,MAAA,CAAA9H,IAAKmE,GACLlE,UAAW8H,EAAGC,EAAOC,uBAAwBhI,GAC7CC,GAAIA,EACJqC,KAAMA,GACO,cAAAE,IAAcyF,EAAUC,EAAuBC,iBAAkBlI,GAC9EsC,MAAOA,IAEPqF,EAACC,cAAAO,QACE,SAAAC,GAAyD,IAAtD1H,EAAM0H,EAAN1H,OAAQgG,EAAK0B,EAAL1B,MAEV,OADAD,GAAeC,EAAOhG,GAEpBiH,gBAACU,EAAI,CACHvI,IAAKqE,GACLzD,OAAQA,EACRgG,MAAOA,EACP4B,UAAWpI,EAAMqI,OACjBC,SAAUhC,GACVzF,SAAUmE,GACVpE,OAAQA,EACRG,cAAeA,EACfS,gBAAiBkF,GACjB7G,UAAWqC,IAEVkE,GAGN,IAIT"}