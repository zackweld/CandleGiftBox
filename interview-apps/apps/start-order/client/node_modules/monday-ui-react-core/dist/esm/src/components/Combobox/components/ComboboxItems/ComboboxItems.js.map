{"version":3,"file":"ComboboxItems.js","sources":["../../../../../../../src/components/Combobox/components/ComboboxItems/ComboboxItems.tsx"],"sourcesContent":["import React, { CSSProperties, forwardRef, RefObject, useCallback, useMemo, useRef } from \"react\";\nimport cx from \"classnames\";\nimport { comboboxItemRenderer } from \"../../ComboboxHelpers/ComboboxHelpers\";\nimport VirtualizedList from \"../../../../components/VirtualizedList/VirtualizedList\";\nimport {\n  COMBOBOX_CATEGORY_ITEM,\n  COMBOBOX_OPTION_ITEM,\n  IComboboxCategoryMap,\n  IComboboxItem,\n  IComboboxOption,\n  IComboboxOptionEvents\n} from \"../ComboboxConstants\";\nimport styles from \"./ComboboxItems.module.scss\";\n\nexport interface ComboboxItemsProps extends IComboboxOptionEvents {\n  className?: string;\n  optionClassName?: string;\n  categories?: IComboboxCategoryMap;\n  options?: IComboboxItem[];\n  optionRenderer?: (option: IComboboxOption) => JSX.Element;\n  activeItemIndex?: number;\n  visualFocusItemIndex?: number;\n  optionLineHeight?: number;\n  shouldScrollToSelectedItem?: boolean;\n  renderOnlyVisibleOptions?: boolean;\n  onActiveCategoryChanged?: (category: IComboboxItem) => void;\n  maxOptionsWithoutScroll?: number;\n  itemsMap?: Map<string, IComboboxItem>;\n  stickyCategories?: boolean;\n  id?: string;\n}\n\nexport const ComboboxItems: React.FC<ComboboxItemsProps> = forwardRef(\n  (\n    {\n      className,\n      optionClassName,\n      categories,\n      options,\n      optionRenderer,\n      activeItemIndex,\n      visualFocusItemIndex,\n      onOptionClick,\n      onOptionEnter,\n      onOptionLeave,\n      optionLineHeight,\n      shouldScrollToSelectedItem,\n      renderOnlyVisibleOptions,\n      onActiveCategoryChanged,\n      maxOptionsWithoutScroll,\n      itemsMap,\n      stickyCategories,\n      id\n    },\n    ref: RefObject<HTMLDivElement>\n  ) => {\n    const activeCategoryId = useRef<string>();\n    const style = useMemo(() => {\n      if (maxOptionsWithoutScroll) {\n        // Adding 0.5 to show next option to indicate scroll is available\n        const maxCount = Math.min(options.length + Object.keys(categories ?? {}).length, maxOptionsWithoutScroll + 0.5);\n        return { height: optionLineHeight * maxCount };\n      }\n      return undefined;\n    }, [maxOptionsWithoutScroll, optionLineHeight, options, categories]);\n\n    const createItemElementRenderer = useCallback(\n      (item: IComboboxItem, index: number, style: CSSProperties) =>\n        comboboxItemRenderer({\n          stickyCategories,\n          item,\n          style,\n          optionEvents: {\n            onOptionClick,\n            onOptionEnter,\n            onOptionLeave\n          },\n          optionRenderData: {\n            className: optionClassName,\n            optionLineHeight,\n            optionRenderer,\n            visualFocusItemIndex,\n            scrollRef: renderOnlyVisibleOptions ? null : ref,\n            activeItemIndex,\n            shouldScrollToSelectedItem\n          },\n          isVirtualized: renderOnlyVisibleOptions\n        }),\n      [\n        onOptionClick,\n        onOptionEnter,\n        onOptionLeave,\n        optionClassName,\n        optionLineHeight,\n        optionRenderer,\n        visualFocusItemIndex,\n        renderOnlyVisibleOptions,\n        ref,\n        activeItemIndex,\n        shouldScrollToSelectedItem\n      ]\n    );\n\n    const onItemsRender = useCallback(\n      ({ firstItemId }: { firstItemId?: string }) => {\n        window.requestAnimationFrame(() => {\n          const itemData = itemsMap.get(firstItemId);\n          if (itemData && (itemData.type === COMBOBOX_CATEGORY_ITEM || itemData.type === COMBOBOX_OPTION_ITEM)) {\n            const newActiveCategoryId =\n              itemData.type === COMBOBOX_OPTION_ITEM && itemData.categoryId ? itemData.categoryId : itemData.id;\n\n            if (newActiveCategoryId !== activeCategoryId.current) {\n              activeCategoryId.current = newActiveCategoryId;\n              const categoryObject = itemsMap.get(activeCategoryId.current);\n              onActiveCategoryChanged(categoryObject);\n            }\n          }\n        });\n      },\n      [itemsMap, onActiveCategoryChanged]\n    );\n\n    let itemsElements;\n\n    // If we request to render only the items which visible in a given moment (optimization for very large lists)\n    if (renderOnlyVisibleOptions) {\n      itemsElements = (\n        <VirtualizedList\n          ref={ref}\n          className={cx(styles.optionsContainer, className)}\n          items={options}\n          itemRenderer={createItemElementRenderer}\n          role=\"listbox\"\n          scrollableClassName={styles.scrollableContainer}\n          onItemsRendered={onItemsRender}\n          style={style}\n          id={id}\n        />\n      );\n    } else {\n      itemsElements = (\n        <div\n          className={cx(styles.scrollableContainer, styles.optionsContainer, className)}\n          role=\"listbox\"\n          id={id}\n          style={style}\n          ref={ref}\n        >\n          {options.map((itemData, index) => createItemElementRenderer(itemData, index, undefined))}\n        </div>\n      );\n    }\n\n    return itemsElements;\n  }\n);\n"],"names":["ComboboxItems","forwardRef","_ref","ref","className","optionClassName","categories","options","optionRenderer","activeItemIndex","visualFocusItemIndex","onOptionClick","onOptionEnter","onOptionLeave","optionLineHeight","shouldScrollToSelectedItem","renderOnlyVisibleOptions","onActiveCategoryChanged","maxOptionsWithoutScroll","itemsMap","stickyCategories","id","activeCategoryId","useRef","style","useMemo","height","Math","min","length","Object","keys","createItemElementRenderer","useCallback","item","index","comboboxItemRenderer","optionEvents","optionRenderData","scrollRef","isVirtualized","onItemsRender","_ref2","firstItemId","window","requestAnimationFrame","itemData","get","type","COMBOBOX_CATEGORY_ITEM","COMBOBOX_OPTION_ITEM","newActiveCategoryId","categoryId","current","categoryObject","React","createElement","VirtualizedList","cx","styles","optionsContainer","items","itemRenderer","role","scrollableClassName","scrollableContainer","onItemsRendered","map","undefined"],"mappings":"8XAgCO,IAAMA,EAA8CC,GACzD,SAAAC,EAqBEC,GACE,IApBAC,EAASF,EAATE,UACAC,EAAeH,EAAfG,gBACAC,EAAUJ,EAAVI,WACAC,EAAOL,EAAPK,QACAC,EAAcN,EAAdM,eACAC,EAAeP,EAAfO,gBACAC,EAAoBR,EAApBQ,qBACAC,EAAaT,EAAbS,cACAC,EAAaV,EAAbU,cACAC,EAAaX,EAAbW,cACAC,EAAgBZ,EAAhBY,iBACAC,EAA0Bb,EAA1Ba,2BACAC,EAAwBd,EAAxBc,yBACAC,EAAuBf,EAAvBe,wBACAC,EAAuBhB,EAAvBgB,wBACAC,EAAQjB,EAARiB,SACAC,EAAgBlB,EAAhBkB,iBACAC,EAAEnB,EAAFmB,GAIIC,EAAmBC,IACnBC,EAAQC,GAAQ,WACpB,GAAIP,EAGF,MAAO,CAAEQ,OAAQZ,EADAa,KAAKC,IAAIrB,EAAQsB,OAASC,OAAOC,KAAKzB,QAAAA,EAAc,CAAA,GAAIuB,OAAQX,EAA0B,IAI9G,GAAE,CAACA,EAAyBJ,EAAkBP,EAASD,IAElD0B,EAA4BC,GAChC,SAACC,EAAqBC,EAAeX,GAAoB,OACvDY,EAAqB,CACnBhB,iBAAAA,EACAc,KAAAA,EACAV,MAAAA,EACAa,aAAc,CACZ1B,cAAAA,EACAC,cAAAA,EACAC,cAAAA,GAEFyB,iBAAkB,CAChBlC,UAAWC,EACXS,iBAAAA,EACAN,eAAAA,EACAE,qBAAAA,EACA6B,UAAWvB,EAA2B,KAAOb,EAC7CM,gBAAAA,EACAM,2BAAAA,GAEFyB,cAAexB,GAEnB,GAAA,CACEL,EACAC,EACAC,EACAR,EACAS,EACAN,EACAE,EACAM,EACAb,EACAM,EACAM,IAIE0B,EAAgBR,GACpB,SAAAS,GAA8C,IAA3CC,EAAWD,EAAXC,YACDC,OAAOC,uBAAsB,WAC3B,IAAMC,EAAW3B,EAAS4B,IAAIJ,GAC9B,GAAIG,IAAaA,EAASE,OAASC,GAA0BH,EAASE,OAASE,GAAuB,CACpG,IAAMC,EACJL,EAASE,OAASE,GAAwBJ,EAASM,WAAaN,EAASM,WAAaN,EAASzB,GAEjG,GAAI8B,IAAwB7B,EAAiB+B,QAAS,CACpD/B,EAAiB+B,QAAUF,EAC3B,IAAMG,EAAiBnC,EAAS4B,IAAIzB,EAAiB+B,SACrDpC,EAAwBqC,EACzB,CACF,CACH,GACF,GACA,CAACnC,EAAUF,IAkCb,OA5BID,EAEAuC,EAACC,cAAAC,GACCtD,IAAKA,EACLC,UAAWsD,EAAGC,EAAOC,iBAAkBxD,GACvCyD,MAAOtD,EACPuD,aAAc9B,EACd+B,KAAK,UACLC,oBAAqBL,EAAOM,oBAC5BC,gBAAiBzB,EACjBjB,MAAOA,EACPH,GAAIA,IAKNkC,EAAAC,cAAA,MAAA,CACEpD,UAAWsD,EAAGC,EAAOM,oBAAqBN,EAAOC,iBAAkBxD,GACnE2D,KAAK,UACL1C,GAAIA,EACJG,MAAOA,EACPrB,IAAKA,GAEJI,EAAQ4D,KAAI,SAACrB,EAAUX,GAAK,OAAKH,EAA0Bc,EAAUX,OAAOiC,EAAU,IAM/F"}