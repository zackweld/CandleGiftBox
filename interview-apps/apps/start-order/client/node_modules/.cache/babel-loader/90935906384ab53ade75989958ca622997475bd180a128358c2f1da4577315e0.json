{"ast":null,"code":"import { slicedToArray as e, defineProperty as o } from \"../../../_virtual/_rollupPluginBabelHelpers.js\";\nimport t, { forwardRef as n, useRef as r, useState as a, useEffect as i } from \"react\";\nimport l from \"classnames\";\nimport s from \"../../hooks/useMergeRef.js\";\nimport u from \"./EditableTypography.module.scss.js\";\nimport \"../../constants/dialog.js\";\nimport { keyCodes as c } from \"../../constants/keyCodes.js\";\nimport \"../../constants/sizes.js\";\nimport \"../../constants/positions.js\";\nimport { useKeyboardButtonPressedFunc as d } from \"../../hooks/useKeyboardButtonPressedFunc.js\";\nimport p from \"../../hooks/usePrevious/index.js\";\nvar m = n(function (n, m) {\n  var f = n.id,\n    y = n.className,\n    h = n[\"data-testid\"],\n    g = n.value,\n    v = n.onChange,\n    b = n.onClick,\n    E = n.readOnly,\n    j = void 0 !== E && E,\n    C = n.ariaLabel,\n    k = void 0 === C ? \"\" : C,\n    P = n.placeholder,\n    w = n.clearable,\n    N = n.typographyClassName,\n    B = n.component,\n    T = n.isEditMode,\n    x = n.onEditModeChange,\n    D = n.tooltipProps,\n    K = n.type,\n    M = n.weight,\n    R = r(null),\n    A = s(m, R),\n    _ = a(T || !1),\n    z = e(_, 2),\n    F = z[0],\n    H = z[1],\n    I = a(g),\n    L = e(I, 2),\n    O = L[0],\n    S = L[1],\n    q = a(0),\n    G = e(q, 2),\n    J = G[0],\n    Q = G[1],\n    U = p(g),\n    V = r(null),\n    W = r(null);\n  function X(e) {\n    j || F || (e.preventDefault(), Y(!0));\n  }\n  function Y(e) {\n    null == x || x(e), H(e);\n  }\n  function Z() {\n    (Y(!1), g !== O) && (O || w && P ? (S(O), null == v || v(O)) : S(g));\n  }\n  i(function () {\n    F || g === U || g === O || S(g);\n  }, [U, F, g, O]), i(function () {\n    H(T);\n  }, [T]);\n  var $ = d(X);\n  return i(function () {\n    var e;\n    F && V.current && (null === (e = V.current) || void 0 === e || e.focus());\n  }, [F]), i(function () {\n    if (W.current) {\n      var e = W.current.getBoundingClientRect();\n      Q(e.width);\n    }\n  }, [O, F]), t.createElement(\"div\", {\n    ref: A,\n    id: f,\n    \"aria-label\": k,\n    \"data-testid\": h,\n    className: l(u.editableTypography, y),\n    role: F ? null : \"button\",\n    onClick: function (e) {\n      null == b || b(e), X(e);\n    },\n    onKeyDown: $\n  }, F && t.createElement(\"input\", {\n    ref: V,\n    className: l(u.input, N),\n    value: O,\n    onChange: function (e) {\n      S(e.target.value);\n    },\n    onKeyDown: function (e) {\n      e.key === c.ENTER && Z(), e.key === c.ESCAPE && (Y(!1), S(g));\n    },\n    onBlur: function () {\n      Z();\n    },\n    \"aria-label\": k,\n    placeholder: P,\n    style: {\n      width: J\n    },\n    role: \"input\"\n  }), t.createElement(B, {\n    ref: W,\n    \"aria-hidden\": F,\n    className: l(u.typography, N, o(o(o({}, u.hidden, F), u.disabled, j), u.placeholder, !O && P)),\n    tabIndex: 0,\n    tooltipProps: D,\n    weight: M,\n    type: K\n  }, O || P));\n});\nexport { m as default };","map":{"version":3,"names":["m","n","f","id","y","className","h","g","value","v","onChange","b","onClick","E","readOnly","j","C","ariaLabel","k","P","placeholder","w","clearable","N","typographyClassName","B","component","T","isEditMode","x","onEditModeChange","D","tooltipProps","K","type","M","weight","R","r","A","s","_","a","z","e","F","H","I","L","O","S","q","G","J","Q","U","p","V","W","X","preventDefault","Y","Z","i","$","d","current","focus","getBoundingClientRect","width","t","createElement","ref","l","u","editableTypography","role","onKeyDown","input","target","key","c","ENTER","ESCAPE","onBlur","style","typography","o","hidden","disabled","tabIndex","default"],"sources":["/Users/zacharyweld/Documents/Code/CandleGiftBox/interview-apps/apps/start-order/client/node_modules/monday-ui-react-core/src/components/EditableTypography/EditableTypography.tsx"],"sourcesContent":["import React, { ElementType, forwardRef, useEffect, useRef, useState } from \"react\";\nimport cx from \"classnames\";\nimport useMergeRef from \"../../hooks/useMergeRef\";\nimport VibeComponentProps from \"../../types/VibeComponentProps\";\nimport VibeComponent from \"../../types/VibeComponent\";\nimport styles from \"./EditableTypography.module.scss\";\nimport { keyCodes } from \"../../constants\";\nimport { useKeyboardButtonPressedFunc } from \"../../hooks/useKeyboardButtonPressedFunc\";\nimport { TooltipProps } from \"../Tooltip/Tooltip\";\nimport usePrevious from \"../../hooks/usePrevious\";\nimport { TextType, TextWeight } from \"../Text/TextConstants\";\nimport { HeadingType, HeadingWeight } from \"../Heading/HeadingConstants\";\n\nexport interface EditableTypographyImplementationProps {\n  /** Value of the text */\n  value: string;\n  /** Will be called whenever the current value changes to a non-empty value */\n  onChange?: (value: string) => void;\n  /** Will be called whenever the component gets clicked */\n  onClick?: (event: React.KeyboardEvent | React.MouseEvent) => void;\n  /** Disables editing mode - component will be just a typography element */\n  readOnly?: boolean;\n  /** Shown in edit mode when the text value is empty */\n  placeholder?: string;\n  /** ARIA Label */\n  ariaLabel?: string;\n  /** Controls the mode of the component (i.e. view/edit mode) */\n  isEditMode?: boolean;\n  /** Will be called when the mode of the component changes */\n  onEditModeChange?: (isEditMode: boolean) => void;\n  /** Override Tooltip props when needed */\n  tooltipProps?: Partial<TooltipProps>;\n}\n\nexport interface EditableTypographyProps extends VibeComponentProps, EditableTypographyImplementationProps {\n  /** A typography component that is being rendered in view mode */\n  component: ElementType;\n  /** Controls the style of the typography component in view mode */\n  typographyClassName: string;\n  /** Shows placeholder when empty, if provided */\n  clearable?: boolean;\n  /** Sets the Text/Heading type */\n  type?: TextType | HeadingType;\n  /** Sets the Text/Heading weight */\n  weight?: TextWeight | HeadingWeight;\n}\n\nconst EditableTypography: VibeComponent<EditableTypographyProps, HTMLElement> = forwardRef(\n  (\n    {\n      id,\n      className,\n      \"data-testid\": dataTestId,\n      value,\n      onChange,\n      onClick,\n      readOnly = false,\n      ariaLabel = \"\",\n      placeholder,\n      clearable,\n      typographyClassName,\n      component: TypographyComponent,\n      isEditMode,\n      onEditModeChange,\n      tooltipProps,\n      type,\n      weight\n    },\n    ref\n  ) => {\n    const componentRef = useRef(null);\n    const mergedRef = useMergeRef(ref, componentRef);\n\n    const [isEditing, setIsEditing] = useState(isEditMode || false);\n    const [inputValue, setInputValue] = useState(value);\n    const [inputWidth, setInputWidth] = useState(0);\n\n    const prevValue = usePrevious(value);\n\n    const inputRef = useRef(null);\n    const typographyRef = useRef(null);\n\n    useEffect(() => {\n      if (!isEditing && value !== prevValue && value !== inputValue) {\n        setInputValue(value);\n      }\n    }, [prevValue, isEditing, value, inputValue]);\n\n    useEffect(() => {\n      setIsEditing(isEditMode);\n    }, [isEditMode]);\n\n    function onTypographyClick(event: React.KeyboardEvent | React.MouseEvent) {\n      onClick?.(event);\n      toggleEditMode(event);\n    }\n\n    function toggleEditMode(event: React.KeyboardEvent | React.MouseEvent) {\n      if (readOnly || isEditing) {\n        return;\n      }\n      event.preventDefault();\n      handleEditModeChange(true);\n    }\n\n    function handleEditModeChange(value: boolean) {\n      onEditModeChange?.(value);\n      setIsEditing(value);\n    }\n\n    function handleInputValueChange() {\n      handleEditModeChange(false);\n\n      if (value === inputValue) {\n        return;\n      }\n\n      const shouldShowPlaceholderWhenEmpty = clearable && placeholder;\n      if (!inputValue && !shouldShowPlaceholderWhenEmpty) {\n        setInputValue(value);\n        return;\n      }\n      setInputValue(inputValue);\n      onChange?.(inputValue);\n    }\n\n    function handleBlur() {\n      handleInputValueChange();\n    }\n\n    function handleKeyDown(event: React.KeyboardEvent<HTMLInputElement>) {\n      if (event.key === keyCodes.ENTER) {\n        handleInputValueChange();\n      }\n      if (event.key === keyCodes.ESCAPE) {\n        handleEditModeChange(false);\n        setInputValue(value);\n      }\n    }\n\n    function handleChange(event: React.ChangeEvent<HTMLInputElement>) {\n      setInputValue(event.target.value);\n    }\n\n    const toggleKeyboardEditMode = useKeyboardButtonPressedFunc(toggleEditMode);\n\n    function focus() {\n      if (inputRef.current) {\n        inputRef.current?.focus();\n      }\n    }\n\n    useEffect(() => {\n      if (isEditing) {\n        focus();\n      }\n    }, [isEditing]);\n\n    useEffect(() => {\n      if (!typographyRef.current) {\n        return;\n      }\n      const { width } = typographyRef.current.getBoundingClientRect();\n      setInputWidth(width);\n    }, [inputValue, isEditing]);\n\n    return (\n      <div\n        ref={mergedRef}\n        id={id}\n        aria-label={ariaLabel}\n        data-testid={dataTestId}\n        className={cx(styles.editableTypography, className)}\n        role={isEditing ? null : \"button\"}\n        onClick={onTypographyClick}\n        onKeyDown={toggleKeyboardEditMode}\n      >\n        {isEditing && (\n          <input\n            ref={inputRef}\n            className={cx(styles.input, typographyClassName)}\n            value={inputValue}\n            onChange={handleChange}\n            onKeyDown={handleKeyDown}\n            onBlur={handleBlur}\n            aria-label={ariaLabel}\n            placeholder={placeholder}\n            style={{ width: inputWidth }}\n            role=\"input\"\n          />\n        )}\n        <TypographyComponent\n          ref={typographyRef}\n          aria-hidden={isEditing}\n          className={cx(styles.typography, typographyClassName, {\n            [styles.hidden]: isEditing,\n            [styles.disabled]: readOnly,\n            [styles.placeholder]: !inputValue && placeholder\n          })}\n          tabIndex={0}\n          tooltipProps={tooltipProps}\n          weight={weight}\n          type={type}\n        >\n          {inputValue || placeholder}\n        </TypographyComponent>\n      </div>\n    );\n  }\n);\n\nexport default EditableTypography;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}