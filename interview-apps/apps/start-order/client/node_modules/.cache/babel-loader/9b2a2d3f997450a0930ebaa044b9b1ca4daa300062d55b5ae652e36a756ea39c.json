{"ast":null,"code":"import { toConsumableArray as n, slicedToArray as e } from \"../../../_virtual/_rollupPluginBabelHelpers.js\";\nimport { useCallback as r, useMemo as t, useState as u, useRef as i, useEffect as o } from \"react\";\nimport l from \"../../hooks/useResizeObserver.js\";\nimport { NOOP as a } from \"../../utils/function-utils.js\";\nimport { UPDATE_SLIDER_SIZE_DEBOUNCE as c } from \"./SliderConstants.js\";\nimport { ensureValueText as f } from \"./SliderHelpers.js\";\nfunction s(u, i, o, l, c, f, s, d, v, m, g, h, p) {\n  var V = r(function (n) {\n      h(n), \"function\" == typeof s && s(n);\n    }, [h, s]),\n    b = r(function (n, e) {\n      return \"\" === e || Number.isNaN(Number(e)) ? 1 === n ? c : f : e > c ? c : f > e ? f : e;\n    }, [f, c]),\n    x = r(function (e) {\n      var r = n(l()),\n        t = r[1];\n      return 1 === e.index ? [r[0], b(e.index, e.newValue)] : [b(e.index, e.newValue), t];\n    }, [b, l]),\n    w = r(function (n) {\n      var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : a,\n        t = x(n),\n        u = e(t, 2),\n        i = u[0],\n        o = u[1];\n      return o > i ? [i, o] : (r(0 === n.index ? 1 : 0), [o, i]);\n    }, [x]),\n    j = r(function (n) {\n      v(n), m(n), g(n);\n    }, [v, m, g]),\n    C = r(function (n) {\n      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0;\n      if (d) {\n        var r = w({\n          newValue: n,\n          index: null != e ? e : i\n        }, arguments.length > 2 && void 0 !== arguments[2] && arguments[2] ? a : m);\n        V(r);\n      } else V(b(null, n));\n    }, [V, w, b, i, d, m]),\n    T = r(function (n) {\n      var e;\n      if (d) {\n        var r = {\n            newValue: n,\n            index: null !== (e = o()) && void 0 !== e ? e : 0\n          },\n          t = w(r, j);\n        V(t);\n      } else V(b(null, n));\n    }, [V, w, j, b, o, d]),\n    N = r(function (n) {\n      var e = d ? u[i] : u;\n      e !== f && C(e - (n || p));\n    }, [u, C, i, f, d, p]),\n    S = r(function (n) {\n      var e = d ? u[i] : u;\n      e !== c && C(e + (n || p));\n    }, [u, C, i, c, d, p]);\n  return t(function () {\n    return {\n      changeThumbValue: C,\n      decreaseValue: N,\n      drugThumb: T,\n      increaseValue: S,\n      setActive: v,\n      setDragging: g,\n      setFocused: m\n    };\n  }, [C, N, T, S, v, g, m]);\n}\nfunction d() {\n  var n = u(null),\n    t = e(n, 2),\n    o = t[0],\n    l = t[1],\n    a = i(null);\n  return [o, r(function (n) {\n    l(n), a.current = n;\n  }, [l, a]), r(function () {\n    return a.current;\n  }, [a])];\n}\nfunction v() {\n  var n = i(null),\n    t = u({\n      left: 0,\n      right: 100,\n      width: 100\n    }),\n    a = e(t, 2),\n    f = a[0],\n    s = a[1],\n    d = r(function () {\n      if (n.current) {\n        var e = n.current.getBoundingClientRect();\n        s({\n          left: e.left,\n          right: e.right,\n          width: e.width\n        });\n      }\n    }, [n, s]);\n  return l({\n    ref: n,\n    callback: d,\n    debounceTime: c\n  }), o(function () {\n    d();\n  }, [d]), {\n    railCoords: f,\n    railRef: n\n  };\n}\nfunction m(n, t, l, c) {\n  var s = function (n) {\n      var r = u(void 0 !== n);\n      return e(r, 1)[0];\n    }(t),\n    d = function (n, r, t) {\n      var i = u(r ? t : n),\n        o = e(i, 2);\n      return r ? [t, a] : [o[0], o[1]];\n    }(n, s, t),\n    v = e(d, 2),\n    m = v[0],\n    g = v[1],\n    h = i(m);\n  o(function () {\n    s && h.current !== m && (h.current = m);\n  }, [s, m]);\n  var p = r(function (n) {\n      g(n), h.current = n;\n    }, [h, g]),\n    V = f(c, m, l);\n  return {\n    actualValue: m,\n    actualValueText: V,\n    getSelectedValue: function () {\n      return h.current;\n    },\n    isControlled: s,\n    setSelectedValue: p\n  };\n}\nexport { d as useDragging, s as useSliderActionsContextValue, v as useSliderRail, m as useSliderValues };","map":{"version":3,"names":["s","u","i","o","l","c","f","d","v","m","g","h","p","V","r","n","b","e","Number","isNaN","x","t","index","newValue","w","arguments","length","a","j","C","T","N","S","changeThumbValue","decreaseValue","drugThumb","increaseValue","setActive","setDragging","setFocused","current","left","right","width","getBoundingClientRect","ref","callback","debounceTime","railCoords","railRef","actualValue","actualValueText","getSelectedValue","isControlled","setSelectedValue","useDragging","useSliderActionsContextValue","useSliderRail","useSliderValues"],"sources":["/Users/zacharyweld/Documents/Code/CandleGiftBoxDemo/CandleGiftBox/interview-apps/apps/start-order/client/node_modules/monday-ui-react-core/src/components/Slider/SliderHooks.ts"],"sourcesContent":["import { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport useResizeObserver from \"../../hooks/useResizeObserver\";\nimport { NOOP } from \"../../utils/function-utils\";\nimport { UPDATE_SLIDER_SIZE_DEBOUNCE } from \"./SliderConstants\";\nimport { ensureValueText } from \"./SliderHelpers\";\n\nfunction _useIsStateControlledFromOutside(value: number | number[]): boolean {\n  const [isControlled] = useState(typeof value !== \"undefined\");\n  return isControlled;\n}\n\nfunction _useSliderValue(\n  defaultValue: number | number[],\n  isControlled: boolean,\n  value: number | number[]\n): [number | number[], (value: number | number[]) => void] {\n  const initialValue = isControlled ? value : defaultValue;\n  const [internalStateValue, setInternalStateValue] = useState(initialValue);\n  if (isControlled) {\n    return [value as number, NOOP];\n  }\n  return [internalStateValue, setInternalStateValue];\n}\n\nexport function useSliderActionsContextValue(\n  actualValue: number | number[],\n  focused: number,\n  getDragging: () => number,\n  getSelectedValue: () => number | number[],\n  max: number,\n  min: number,\n  onChange: (value: number | number[]) => void,\n  ranged: boolean,\n  setActive: (value: number) => void,\n  setFocused: (value: number) => void,\n  setDragging: (value: number) => void,\n  setSelectedValue: (value: number | number[]) => void,\n  step: number\n) {\n  const _changeValueOrValues = useCallback(\n    (newValueOrValues: number | number[]) => {\n      setSelectedValue(newValueOrValues);\n      if (typeof onChange === \"function\") {\n        onChange(newValueOrValues);\n      }\n    },\n    [setSelectedValue, onChange]\n  );\n\n  const _validateValue = useCallback(\n    (index: number, newValue: number | number[] | string): number => {\n      if (newValue === \"\" || Number.isNaN(Number(newValue))) {\n        return index === 1 ? max : min;\n      }\n      if (newValue > max) {\n        return max;\n      }\n      if (newValue < min) {\n        return min;\n      }\n      return newValue as number;\n    },\n    [min, max]\n  );\n\n  const _calculateNewValues = useCallback(\n    (thumb: { index: number; newValue: number | number[] | string }): number[] => {\n      const [startValue, endValue] = [...(getSelectedValue() as number[])];\n      if (thumb.index === 1) {\n        return [startValue, _validateValue(thumb.index, thumb.newValue)];\n      }\n      return [_validateValue(thumb.index, thumb.newValue), endValue];\n    },\n    [_validateValue, getSelectedValue]\n  );\n\n  const _manageRangedValues = useCallback(\n    (thumb: { index: number; newValue: number | number[] | string }, switchCb: (value: number) => void = NOOP) => {\n      const [startValue, endValue] = _calculateNewValues(thumb);\n      if (startValue < endValue) {\n        // no need to switch, same thumb stay active\n        return [startValue, endValue];\n      }\n      // switch active thumb + end and start values\n      switchCb(thumb.index === 0 ? 1 : 0);\n      return [endValue, startValue];\n    },\n    [_calculateNewValues]\n  );\n\n  const _switchDraggingThumb = useCallback(\n    (switchTo: number) => {\n      setActive(switchTo);\n      setFocused(switchTo);\n      setDragging(switchTo);\n    },\n    [setActive, setFocused, setDragging]\n  );\n\n  const changeThumbValue = useCallback(\n    (newValue: number | string, thumbIndex: number = undefined, cancelFocus = false) => {\n      if (!ranged) {\n        _changeValueOrValues(_validateValue(null, newValue));\n        return;\n      }\n      const currentThumb = { newValue, index: thumbIndex ?? focused };\n      const switchCb = cancelFocus ? NOOP : setFocused;\n      const newValues = _manageRangedValues(currentThumb, switchCb);\n      _changeValueOrValues(newValues);\n    },\n    [_changeValueOrValues, _manageRangedValues, _validateValue, focused, ranged, setFocused]\n  );\n\n  const drugThumb = useCallback(\n    (newValue: number | number[]) => {\n      if (!ranged) {\n        _changeValueOrValues(_validateValue(null, newValue));\n        return;\n      }\n      const currentThumb = { newValue, index: getDragging() ?? 0 };\n      const newValues = _manageRangedValues(currentThumb, _switchDraggingThumb);\n      _changeValueOrValues(newValues);\n    },\n    [_changeValueOrValues, _manageRangedValues, _switchDraggingThumb, _validateValue, getDragging, ranged]\n  );\n\n  const decreaseValue = useCallback(\n    (consumerStep: number) => {\n      const currentValue = ranged ? (actualValue as number[])[focused] : (actualValue as number);\n      if (currentValue === min) {\n        return;\n      }\n      const finalStep = consumerStep || step;\n      const newValue = currentValue - finalStep;\n      changeThumbValue(newValue);\n    },\n    [actualValue, changeThumbValue, focused, min, ranged, step]\n  );\n\n  const increaseValue = useCallback(\n    (consumerStep?: number) => {\n      const currentValue = ranged ? (actualValue as number[])[focused] : (actualValue as number);\n      if (currentValue === max) {\n        return;\n      }\n      const finalStep = consumerStep || step;\n      const newValue = currentValue + finalStep;\n      changeThumbValue(newValue);\n    },\n    [actualValue, changeThumbValue, focused, max, ranged, step]\n  );\n\n  return useMemo(\n    () => ({\n      changeThumbValue,\n      decreaseValue,\n      drugThumb,\n      increaseValue,\n      setActive,\n      setDragging,\n      setFocused\n    }),\n    [changeThumbValue, decreaseValue, drugThumb, increaseValue, setActive, setDragging, setFocused]\n  );\n}\n\nexport function useDragging(): [number, (value: number) => void, () => number] {\n  const [dragging, setStateDragging] = useState<number>(null);\n  const draggingRef = useRef(null);\n\n  const setDragging = useCallback(\n    (index: number) => {\n      setStateDragging(index);\n      draggingRef.current = index;\n    },\n    [setStateDragging, draggingRef]\n  );\n  const getDragging = useCallback(() => draggingRef.current, [draggingRef]);\n  return [dragging, setDragging, getDragging];\n}\n\nexport function useSliderRail() {\n  const railRef = useRef(null);\n  const [railCoords, setRailCoords] = useState({ left: 0, right: 100, width: 100 });\n\n  const defineRailCoords = useCallback(() => {\n    if (!railRef.current) {\n      return;\n    }\n    const railRect = railRef.current.getBoundingClientRect();\n    const { left, right, width } = railRect;\n    setRailCoords({ left, right, width });\n  }, [railRef, setRailCoords]);\n\n  useResizeObserver({\n    ref: railRef,\n    callback: defineRailCoords,\n    debounceTime: UPDATE_SLIDER_SIZE_DEBOUNCE\n  });\n\n  useEffect(() => {\n    defineRailCoords();\n  }, [defineRailCoords]);\n\n  return { railCoords, railRef };\n}\n\nexport function useSliderValues(\n  defaultValue: number | number[],\n  value: number | number[],\n  valueFormatter: (value: number) => string,\n  valueText: string\n): {\n  actualValue: number | number[];\n  actualValueText: string | string[];\n  getSelectedValue: () => number | number[];\n  isControlled: boolean;\n  setSelectedValue: (value: number) => void;\n} {\n  const isControlled = _useIsStateControlledFromOutside(value);\n  const [actualValue, setStateSelectedValue] = _useSliderValue(defaultValue, isControlled, value);\n  const valueRef = useRef(actualValue);\n\n  // Update ref when actualValue was changed from outside in controlled mode\n  useEffect(() => {\n    if (isControlled && valueRef.current !== actualValue) {\n      valueRef.current = actualValue;\n    }\n  }, [isControlled, actualValue]);\n\n  const setSelectedValue = useCallback(\n    (newValue: number) => {\n      setStateSelectedValue(newValue);\n      valueRef.current = newValue;\n    },\n    [valueRef, setStateSelectedValue]\n  );\n\n  const getSelectedValue = () => valueRef.current;\n\n  const actualValueText = ensureValueText(valueText, actualValue, valueFormatter);\n  return { actualValue, actualValueText, getSelectedValue, isControlled, setSelectedValue };\n}\n"],"mappings":";;;;;;AAwBM,SAAUA,EACdC,CAAA,EACAC,CAAA,EACAC,CAAA,EACAC,CAAA,EACAC,CAAA,EACAC,CAAA,EACAN,CAAA,EACAO,CAAA,EACAC,CAAA,EACAC,CAAA,EACAC,CAAA,EACAC,CAAA,EACAC,CAAA;EAEA,IAAMC,CAAA,GAAuBC,CAAA,CAC3B,UAACC,CAAA;MACCJ,CAAA,CAAiBI,CAAA,GACO,qBAAbf,CAAA,IACTA,CAAA,CAASe,CAAA,CAEb;IAAA,GACA,CAACJ,CAAA,EAAkBX,CAAA;IAGfgB,CAAA,GAAiBF,CAAA,CACrB,UAACC,CAAA,EAAeE,CAAA;MACd,OAAiB,OAAbA,CAAA,IAAmBC,MAAA,CAAOC,KAAA,CAAMD,MAAA,CAAOD,CAAA,KACxB,MAAVF,CAAA,GAAcV,CAAA,GAAMC,CAAA,GAEzBW,CAAA,GAAWZ,CAAA,GACNA,CAAA,GAEMC,CAAA,GAAXW,CAAA,GACKX,CAAA,GAEFW,CACT;IAAA,GACA,CAACX,CAAA,EAAKD,CAAA;IAGFe,CAAA,GAAsBN,CAAA,CAC1B,UAACG,CAAA;MACC,IAAAH,CAAA,GAAAC,CAAA,CAAoCX,CAAA;QAAjBiB,CAAA,GAAQP,CAAA;MAC3B,OAAoB,MAAhBG,CAAA,CAAMK,KAAA,GACD,CAFQR,CAAA,KAEKE,CAAA,CAAeC,CAAA,CAAMK,KAAA,EAAOL,CAAA,CAAMM,QAAA,KAEjD,CAACP,CAAA,CAAeC,CAAA,CAAMK,KAAA,EAAOL,CAAA,CAAMM,QAAA,GAAWF,CAAA,CACvD;IAAA,GACA,CAACL,CAAA,EAAgBZ,CAAA;IAGboB,CAAA,GAAsBV,CAAA,CAC1B,UAACC,CAAA;MAA4G,IAA5CD,CAAA,GAAAW,SAAA,CAAAC,MAAA,mBAAAD,SAAA,MAAAA,SAAA,MAAoCE,CAAA;QACnGN,CAAA,GAA+BD,CAAA,CAAoBL,CAAA;QAAMd,CAAA,GAAAgB,CAAA,CAAAI,CAAA;QAAlDnB,CAAA,GAAUD,CAAA;QAAEE,CAAA,GAAQF,CAAA;MAC3B,OAAiBE,CAAA,GAAbD,CAAA,GAEK,CAACA,CAAA,EAAYC,CAAA,KAGtBW,CAAA,CAAyB,MAAhBC,CAAA,CAAMO,KAAA,GAAc,IAAI,IAC1B,CAACnB,CAAA,EAAUD,CAAA,EACpB;IAAA,GACA,CAACkB,CAAA;IAGGQ,CAAA,GAAuBd,CAAA,CAC3B,UAACC,CAAA;MACCP,CAAA,CAAUO,CAAA,GACVN,CAAA,CAAWM,CAAA,GACXL,CAAA,CAAYK,CAAA,CACb;IAAA,GACD,CAACP,CAAA,EAAWC,CAAA,EAAYC,CAAA;IAGpBmB,CAAA,GAAmBf,CAAA,CACvB,UAACC,CAAA;MAAkF,IAAvDE,CAAA,GAAqBQ,SAAA,CAAAC,MAAA,mBAAAD,SAAA,MAAAA,SAAA;MAC/C,IAAKlB,CAAA,EAAL;QAIA,IAEMO,CAAA,GAAYU,CAAA,CAFG;UAAED,QAAA,EAAAR,CAAA;UAAUO,KAAA,EAAO,QAAAL,CAAA,GAAAA,CAAA,GAAcf;QAAA,GALeuB,SAAA,CAAAC,MAAA,mBAAAD,SAAA,OAAAA,SAAA,MAMtCE,CAAA,GAAOlB,CAAA;QAEtCI,CAAA,CAAqBC,CAAA,CAJpB;MAAA,OAFCD,CAAA,CAAqBG,CAAA,CAAe,MAAMD,CAAA,EAO9C;IAAA,GACA,CAACF,CAAA,EAAsBW,CAAA,EAAqBR,CAAA,EAAgBd,CAAA,EAASK,CAAA,EAAQE,CAAA;IAGzEqB,CAAA,GAAYhB,CAAA,CAChB,UAACC,CAAA;MAAA,IAAAE,CAAA;MACC,IAAKV,CAAA,EAAL;QAIA,IAAMO,CAAA,GAAe;YAAES,QAAA,EAAAR,CAAA;YAAUO,KAAA,EAAwB,UAAjBL,CAAA,GAAAd,CAAA,YAAiB,MAAAc,CAAA,GAAAA,CAAA;UAAA;UACnDI,CAAA,GAAYG,CAAA,CAAoBV,CAAA,EAAcc,CAAA;QACpDf,CAAA,CAAqBQ,CAAA,CAHpB;MAAA,OAFCR,CAAA,CAAqBG,CAAA,CAAe,MAAMD,CAAA,EAM9C;IAAA,GACA,CAACF,CAAA,EAAsBW,CAAA,EAAqBI,CAAA,EAAsBZ,CAAA,EAAgBb,CAAA,EAAaI,CAAA;IAG3FwB,CAAA,GAAgBjB,CAAA,CACpB,UAACC,CAAA;MACC,IAAME,CAAA,GAAeV,CAAA,GAAUN,CAAA,CAAyBC,CAAA,IAAYD,CAAA;MAChEgB,CAAA,KAAiBX,CAAA,IAKrBuB,CAAA,CADiBZ,CAAA,IADCF,CAAA,IAAgBH,CAAA,EAGpC;IAAA,GACA,CAACX,CAAA,EAAa4B,CAAA,EAAkB3B,CAAA,EAASI,CAAA,EAAKC,CAAA,EAAQK,CAAA;IAGlDoB,CAAA,GAAgBlB,CAAA,CACpB,UAACC,CAAA;MACC,IAAME,CAAA,GAAeV,CAAA,GAAUN,CAAA,CAAyBC,CAAA,IAAYD,CAAA;MAChEgB,CAAA,KAAiBZ,CAAA,IAKrBwB,CAAA,CADiBZ,CAAA,IADCF,CAAA,IAAgBH,CAAA,EAGpC;IAAA,GACA,CAACX,CAAA,EAAa4B,CAAA,EAAkB3B,CAAA,EAASG,CAAA,EAAKE,CAAA,EAAQK,CAAA;EAGxD,OAAOS,CAAA,CACL;IAAA,OAAO;MACLY,gBAAA,EAAAJ,CAAA;MACAK,aAAA,EAAAH,CAAA;MACAI,SAAA,EAAAL,CAAA;MACAM,aAAA,EAAAJ,CAAA;MACAK,SAAA,EAAA7B,CAAA;MACA8B,WAAA,EAAA5B,CAAA;MACA6B,UAAA,EAAA9B;IAAA,CACD;EAAA,GACD,CAACoB,CAAA,EAAkBE,CAAA,EAAeD,CAAA,EAAWE,CAAA,EAAexB,CAAA,EAAWE,CAAA,EAAaD,CAAA,EAExF;AAAA;AAAA,SAEgBF,EAAA;EACd,IAAAQ,CAAA,GAAqCd,CAAA,CAAiB;IAAKoB,CAAA,GAAAJ,CAAA,CAAAF,CAAA;IAApDZ,CAAA,GAAQkB,CAAA;IAAEjB,CAAA,GAAgBiB,CAAA;IAC3BM,CAAA,GAAczB,CAAA,CAAO;EAU3B,OAAO,CAACC,CAAA,EARYW,CAAA,CAClB,UAACC,CAAA;IACCX,CAAA,CAAiBW,CAAA,GACjBY,CAAA,CAAYa,OAAA,GAAUzB,CACxB;EAAA,GACA,CAACX,CAAA,EAAkBuB,CAAA,IAEDb,CAAA,CAAY;IAAA,OAAMa,CAAA,CAAYa,OAAA;EAAA,GAAS,CAACb,CAAA,GAE9D;AAAA;AAAA,SAEgBnB,EAAA;EACd,IAAMO,CAAA,GAAUb,CAAA,CAAO;IACvBmB,CAAA,GAAoCpB,CAAA,CAAS;MAAEwC,IAAA,EAAM;MAAGC,KAAA,EAAO;MAAKC,KAAA,EAAO;IAAA;IAAMhB,CAAA,GAAAV,CAAA,CAAAI,CAAA;IAA1Ef,CAAA,GAAUqB,CAAA;IAAE3B,CAAA,GAAa2B,CAAA;IAE1BpB,CAAA,GAAmBO,CAAA,CAAY;MACnC,IAAKC,CAAA,CAAQyB,OAAA,EAAb;QAGA,IAAMvB,CAAA,GAAWF,CAAA,CAAQyB,OAAA,CAAQI,qBAAA;QAEjC5C,CAAA,CAAc;UAAEyC,IAAA,EADexB,CAAA,CAAvBwB,IAAA;UACcC,KAAA,EADSzB,CAAA,CAAjByB,KAAA;UACeC,KAAA,EADE1B,CAAA,CAAV0B;QAAA,EAFpB;MAAA;IAIH,GAAG,CAAC5B,CAAA,EAASf,CAAA;EAYb,OAVAI,CAAA,CAAkB;IAChByC,GAAA,EAAK9B,CAAA;IACL+B,QAAA,EAAUvC,CAAA;IACVwC,YAAA,EAAc1C;EAAA,IAGhBF,CAAA,CAAU;IACRI,CAAA,EACF;EAAA,GAAG,CAACA,CAAA,IAEG;IAAEyC,UAAA,EAAA1C,CAAA;IAAY2C,OAAA,EAAAlC;EAAA,CACvB;AAAA;AAEM,SAAUN,EACdM,CAAA,EACAM,CAAA,EACAjB,CAAA,EACAC,CAAA;EAQA,IAAML,CAAA,GArNR,UAA0Ce,CAAA;MACxC,IAAAD,CAAA,GAAuBb,CAAA,MAA0B,MAAVc,CAAA;MACvC,OAD6DE,CAAA,CAAAH,CAAA,KAA1C,EAErB;IAAA,CAkNuB,CAAiCO,CAAA;IACtDd,CAAA,GAjNF,UACEQ,CAAA,EACAD,CAAA,EACAO,CAAA;MAEA,IACAnB,CAAA,GAAoDD,CAAA,CAD/Ba,CAAA,GAAeO,CAAA,GAAQN,CAAA;QAC8BZ,CAAA,GAAAc,CAAA,CAAAf,CAAA;MAC1E,OAAIY,CAAA,GACK,CAACO,CAAA,EAAiBM,CAAA,IAEpB,CAJkBxB,CAAA,KAAuBA,CAAA,IAKlD;IAAA,CAsM+C,CAAgBY,CAAA,EAAcf,CAAA,EAAcqB,CAAA;IAAMb,CAAA,GAAAS,CAAA,CAAAV,CAAA;IAAxFE,CAAA,GAAWD,CAAA;IAAEE,CAAA,GAAqBF,CAAA;IACnCG,CAAA,GAAWT,CAAA,CAAOO,CAAA;EAGxBN,CAAA,CAAU;IACJH,CAAA,IAAgBW,CAAA,CAAS6B,OAAA,KAAY/B,CAAA,KACvCE,CAAA,CAAS6B,OAAA,GAAU/B,CAAA,CAEvB;EAAA,GAAG,CAACT,CAAA,EAAcS,CAAA;EAElB,IAAMG,CAAA,GAAmBE,CAAA,CACvB,UAACC,CAAA;MACCL,CAAA,CAAsBK,CAAA,GACtBJ,CAAA,CAAS6B,OAAA,GAAUzB,CACrB;IAAA,GACA,CAACJ,CAAA,EAAUD,CAAA;IAKPG,CAAA,GAAkBP,CAAA,CAAgBD,CAAA,EAAWI,CAAA,EAAaL,CAAA;EAChE,OAAO;IAAE8C,WAAA,EAAAzC,CAAA;IAAa0C,eAAA,EAAAtC,CAAA;IAAiBuC,gBAAA,EAHd,SAAAA,CAAA;MAAH,OAASzC,CAAA,CAAS6B,OAAO;IAAA;IAGUa,YAAA,EAAArD,CAAA;IAAcsD,gBAAA,EAAA1C;EAAA,CACzE;AAAA;AAAA,SAAAL,CAAA,IAAAgD,WAAA,EAAAvD,CAAA,IAAAwD,4BAAA,EAAAhD,CAAA,IAAAiD,aAAA,EAAAhD,CAAA,IAAAiD,eAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}