{"ast":null,"code":"import { useCallback as e, useMemo as t, useEffect as n, useRef as s } from \"react\";\nimport i from \"../useKeyEvent/index.js\";\nimport o from \"../useEventListener/index.js\";\nimport u from \"../usePrevious/index.js\";\nimport { getNextSelectableIndex as c, getPreviousSelectableIndex as r } from \"./useActiveDescendantListFocusHelpers.js\";\nimport l from \"../useListenFocusTriggers/index.js\";\nvar a;\n!function (e) {\n  e.UP = \"ArrowUp\", e.DOWN = \"ArrowDown\", e.RIGHT = \"ArrowRight\", e.LEFT = \"ArrowLeft\";\n}(a || (a = {}));\nvar m = \"Enter\";\nfunction I(t) {\n  var n = t.itemsCount,\n    s = t.focusedElementRef,\n    o = t.visualFocusItemIndex,\n    u = t.setVisualFocusItemIndex,\n    l = t.isHorizontalList,\n    m = t.isItemSelectable,\n    I = t.listenerOptions,\n    d = t.triggeredByKeyboard,\n    f = l ? a.RIGHT : a.DOWN,\n    v = l ? a.LEFT : a.UP,\n    x = e(function (e) {\n      var t;\n      document.activeElement === s.current && (!d.current && (d.current = !0, o > -1) || (e === f ? t = c({\n        isItemSelectable: m,\n        visualFocusItemIndex: o,\n        itemsCount: n\n      }) : e === v && (t = r({\n        isItemSelectable: m,\n        visualFocusItemIndex: o,\n        itemsCount: n\n      })), t > -1 && t !== o && u(t)));\n    }, [s, d, f, v, o, u, m, n]),\n    F = e(function () {\n      x(v);\n    }, [v, x]),\n    b = e(function () {\n      x(f);\n    }, [f, x]);\n  i(Object.assign({\n    keys: [f],\n    callback: b\n  }, I)), i(Object.assign({\n    keys: [v],\n    callback: F\n  }, I));\n}\nfunction d(n) {\n  var s = n.visualFocusItemIndex,\n    o = n.focusedElementRef,\n    u = n.itemsCount,\n    c = n.setVisualFocusItemIndex,\n    r = n.onItemClick,\n    l = n.isItemSelectable,\n    a = n.listenerOptions,\n    I = void 0 === a ? void 0 : a,\n    d = n.isIgnoreSpaceAsItemSelection,\n    f = void 0 !== d && d,\n    v = t(function () {\n      return f ? [m] : [m, \" \"];\n    }, [f]),\n    x = e(function (e, t) {\n      r && t >= 0 && u > t && l(t) && (s !== t && c(t), r(e, t));\n    }, [u, r, l, s, c]),\n    F = e(function (e) {\n      o.current.contains(document.activeElement) && x(e, s);\n    }, [x, o, s]);\n  i(Object.assign({\n    keys: v,\n    callback: F\n  }, I));\n}\nfunction f(t) {\n  var s = t.focusedElementRef,\n    i = t.visualFocusItemIndex,\n    c = t.setVisualFocusItemIndex,\n    r = u(s),\n    l = e(function () {\n      -1 !== i && c(-1);\n    }, [c, i]);\n  n(function () {\n    null === (null == s ? void 0 : s.current) && null !== (null == r ? void 0 : r.current) && l();\n  }, [s.current, r, l]), o({\n    eventName: \"blur\",\n    ref: s,\n    callback: l\n  });\n}\nfunction v(t) {\n  var n = t.focusedElementRef,\n    i = t.isItemSelectable,\n    o = t.visualFocusItemIndex,\n    u = t.setVisualFocusItemIndex,\n    r = t.itemsCount,\n    a = t.defaultVisualFocusItemIndex,\n    m = void 0 === a ? -1 : a,\n    I = s(!1),\n    d = e(function () {\n      var e;\n      (I.current = !0, o !== m) && (e = i(m) ? m : c({\n        isItemSelectable: i,\n        itemsCount: r,\n        visualFocusItemIndex: m\n      }), u(e));\n    }, [m, i, r, u, I, o]),\n    f = e(function () {\n      I.current = !1;\n    }, [I]);\n  return l({\n    ref: n,\n    onFocusByKeyboard: d,\n    onFocusByMouse: f\n  }), {\n    triggeredByKeyboard: I\n  };\n}\nfunction x(e) {\n  var t = e.visualFocusItemIndex,\n    s = e.itemsIds,\n    i = e.isItemSelectable,\n    o = e.setVisualFocusItemIndex,\n    r = u(s);\n  n(function () {\n    var e;\n    void 0 !== r && r !== s && void 0 !== r && -1 !== t ? e = s.indexOf(r[t]) : e = t;\n    if (e !== t) if (i(e)) o(e);else {\n      var n = c({\n        isItemSelectable: i,\n        visualFocusItemIndex: e,\n        itemsCount: s.length\n      });\n      o(n);\n    }\n  }, [t, s, i, o, r]);\n}\nexport { f as useCleanVisualFocusOnBlur, x as useKeepFocusOnItemWhenListChanged, v as useSetDefaultItemOnFocusEvent, I as useSupportArrowsKeyboardNavigation, d as useSupportPressItemKeyboardNavigation };","map":{"version":3,"names":["a","e","UP","DOWN","RIGHT","LEFT","m","I","t","n","itemsCount","s","focusedElementRef","o","visualFocusItemIndex","u","setVisualFocusItemIndex","l","isHorizontalList","isItemSelectable","listenerOptions","d","triggeredByKeyboard","f","v","x","document","activeElement","current","c","r","F","b","i","Object","assign","keys","callback","onItemClick","isIgnoreSpaceAsItemSelection","contains","eventName","ref","defaultVisualFocusItemIndex","onFocusByKeyboard","onFocusByMouse","itemsIds","indexOf","length","useCleanVisualFocusOnBlur","useKeepFocusOnItemWhenListChanged","useSetDefaultItemOnFocusEvent","useSupportArrowsKeyboardNavigation","useSupportPressItemKeyboardNavigation"],"sources":["/Users/zacharyweld/Documents/Code/CandleGiftBoxDemo/CandleGiftBox/interview-apps/apps/start-order/client/node_modules/monday-ui-react-core/src/hooks/useActiveDescendantListFocus/useActiveDescendantListFocusHooks.ts"],"sourcesContent":["import React, { MutableRefObject, useCallback, useEffect, useMemo, useRef } from \"react\";\nimport useKeyEvent, { UseKeyEventArgs } from \"../useKeyEvent\";\nimport useEventListener from \"../useEventListener\";\nimport usePrevious from \"../usePrevious\";\nimport { getNextSelectableIndex, getPreviousSelectableIndex } from \"./useActiveDescendantListFocusHelpers\";\nimport useListenFocusTriggers from \"../useListenFocusTriggers\";\n\nenum ArrowDirection {\n  UP = \"ArrowUp\",\n  DOWN = \"ArrowDown\",\n  RIGHT = \"ArrowRight\",\n  LEFT = \"ArrowLeft\"\n}\n\nconst ENTER_KEY = \"Enter\";\nconst SPACE_KEY = \" \";\n\nexport function useSupportArrowsKeyboardNavigation({\n  itemsCount,\n  focusedElementRef,\n  visualFocusItemIndex,\n  setVisualFocusItemIndex,\n  isHorizontalList,\n  isItemSelectable,\n  listenerOptions,\n  triggeredByKeyboard\n}: {\n  itemsCount: number;\n  focusedElementRef: MutableRefObject<HTMLElement>;\n  visualFocusItemIndex: number;\n  setVisualFocusItemIndex: (index: number) => void;\n  isHorizontalList: boolean;\n  isItemSelectable: (index: number) => boolean;\n  triggeredByKeyboard: MutableRefObject<boolean>;\n  listenerOptions: Omit<UseKeyEventArgs, \"keys\" | \"callback\">;\n}) {\n  const nextArrow = isHorizontalList ? ArrowDirection.RIGHT : ArrowDirection.DOWN;\n  const backArrow = isHorizontalList ? ArrowDirection.LEFT : ArrowDirection.UP;\n\n  const onArrowKeyEvent = useCallback(\n    (direction: ArrowDirection) => {\n      // we desire to change the visual focus item only if the user pressed on the keyboard arrows keys while\n      // the focusedElementRef is naturally focus\n      if (document.activeElement !== focusedElementRef.current) {\n        return;\n      }\n\n      // If the focusedElementRef is naturally focus but this is the first keyboard interaction of the user, we will mark future user interactions as trigger by keyboard (until the next mouse interaction)\n      // that from now on the interactions are trigger by keyboard (until the next mouse interaction)\n      if (!triggeredByKeyboard.current) {\n        triggeredByKeyboard.current = true;\n\n        // If the focusedElementRef is naturally focus but this is the first keyboard interaction of the user, we want only to display the item\n        // which right now visually focus without changing it.\n        if (visualFocusItemIndex > -1) {\n          return;\n        }\n      }\n\n      let newIndex;\n\n      // We will change the visual focused item index according to the direction of the pressed arrow\n      if (direction === nextArrow) {\n        newIndex = getNextSelectableIndex({ isItemSelectable, visualFocusItemIndex, itemsCount });\n      } else if (direction === backArrow) {\n        newIndex = getPreviousSelectableIndex({ isItemSelectable, visualFocusItemIndex, itemsCount });\n      }\n\n      if (newIndex > -1 && newIndex !== visualFocusItemIndex) setVisualFocusItemIndex(newIndex);\n    },\n    [\n      focusedElementRef,\n      triggeredByKeyboard,\n      nextArrow,\n      backArrow,\n      visualFocusItemIndex,\n      setVisualFocusItemIndex,\n      isItemSelectable,\n      itemsCount\n    ]\n  );\n  const onArrowBack = useCallback(() => {\n    onArrowKeyEvent(backArrow);\n  }, [backArrow, onArrowKeyEvent]);\n\n  const onArrowNext = useCallback(() => {\n    onArrowKeyEvent(nextArrow);\n  }, [nextArrow, onArrowKeyEvent]);\n\n  useKeyEvent({\n    keys: [nextArrow],\n    callback: onArrowNext,\n    ...listenerOptions\n  });\n\n  useKeyEvent({\n    keys: [backArrow],\n    callback: onArrowBack,\n    ...listenerOptions\n  });\n}\n\nexport function useSupportPressItemKeyboardNavigation({\n  visualFocusItemIndex,\n  focusedElementRef,\n  itemsCount,\n  setVisualFocusItemIndex,\n  onItemClick,\n  isItemSelectable,\n  listenerOptions = undefined,\n  isIgnoreSpaceAsItemSelection = false\n}: {\n  visualFocusItemIndex: number;\n  focusedElementRef: MutableRefObject<HTMLElement>;\n  itemsCount: number;\n  setVisualFocusItemIndex: (index: number) => void;\n  onItemClick: (event: React.MouseEvent | React.KeyboardEvent, index: number) => void;\n  isItemSelectable: (index: number) => boolean;\n  listenerOptions: Omit<UseKeyEventArgs, \"keys\" | \"callback\">;\n  isIgnoreSpaceAsItemSelection: boolean;\n}) {\n  const pressKeys = useMemo(\n    () => (isIgnoreSpaceAsItemSelection ? [ENTER_KEY] : [ENTER_KEY, SPACE_KEY]),\n    [isIgnoreSpaceAsItemSelection]\n  );\n\n  const baseOnClickCallback = useCallback(\n    (event: React.KeyboardEvent, itemIndex: number) => {\n      const hasValidIndex = itemIndex >= 0 && itemIndex < itemsCount;\n      if (!onItemClick || !hasValidIndex || !isItemSelectable(itemIndex)) return;\n      if (visualFocusItemIndex !== itemIndex) setVisualFocusItemIndex(itemIndex);\n      onItemClick(event, itemIndex);\n    },\n    [itemsCount, onItemClick, isItemSelectable, visualFocusItemIndex, setVisualFocusItemIndex]\n  );\n\n  const keyboardOnSelectCallback = useCallback(\n    (event: React.KeyboardEvent) => {\n      // we desire to change the trigger the active item on click callback only if the user pressed on the keyboard arrows keys while\n      // the focusedElementRef is naturally focus\n      if (focusedElementRef.current.contains(document.activeElement)) {\n        baseOnClickCallback(event, visualFocusItemIndex);\n      }\n    },\n    [baseOnClickCallback, focusedElementRef, visualFocusItemIndex]\n  );\n\n  useKeyEvent({\n    keys: pressKeys,\n    callback: keyboardOnSelectCallback,\n    ...listenerOptions\n  });\n}\n\nexport function useCleanVisualFocusOnBlur({\n  focusedElementRef,\n  visualFocusItemIndex,\n  setVisualFocusItemIndex\n}: {\n  focusedElementRef: MutableRefObject<HTMLElement>;\n  visualFocusItemIndex: number;\n  setVisualFocusItemIndex: (index: number) => void;\n}) {\n  const previousFocusedElementRef = usePrevious(focusedElementRef);\n\n  const onBlurCallback = useCallback(() => {\n    if (visualFocusItemIndex !== -1) {\n      setVisualFocusItemIndex(-1);\n    }\n  }, [setVisualFocusItemIndex, visualFocusItemIndex]);\n\n  // if element unmount act like element got blur event\n  useEffect(() => {\n    // if element unmount\n    if (focusedElementRef?.current === null && previousFocusedElementRef?.current !== null) {\n      onBlurCallback();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [focusedElementRef.current, previousFocusedElementRef, onBlurCallback]);\n\n  useEventListener({\n    eventName: \"blur\",\n    ref: focusedElementRef,\n    callback: onBlurCallback\n  });\n}\n\nexport function useSetDefaultItemOnFocusEvent({\n  focusedElementRef,\n  isItemSelectable,\n  visualFocusItemIndex,\n  setVisualFocusItemIndex,\n  itemsCount,\n  defaultVisualFocusItemIndex = -1\n}: {\n  focusedElementRef: MutableRefObject<HTMLElement>;\n  isItemSelectable: (index: number) => boolean;\n  visualFocusItemIndex: number;\n  setVisualFocusItemIndex: (index: number) => void;\n  itemsCount: number;\n  defaultVisualFocusItemIndex: number;\n}) {\n  const triggeredByKeyboard = useRef(false);\n\n  const onFocusByKeyboard = useCallback(() => {\n    triggeredByKeyboard.current = true;\n    if (visualFocusItemIndex !== defaultVisualFocusItemIndex) {\n      let newVisualFocusIndex;\n      if (isItemSelectable(defaultVisualFocusItemIndex)) {\n        newVisualFocusIndex = defaultVisualFocusItemIndex;\n      } else {\n        newVisualFocusIndex = getNextSelectableIndex({\n          isItemSelectable,\n          itemsCount,\n          visualFocusItemIndex: defaultVisualFocusItemIndex\n        });\n      }\n      setVisualFocusItemIndex(newVisualFocusIndex);\n    }\n  }, [\n    defaultVisualFocusItemIndex,\n    isItemSelectable,\n    itemsCount,\n    setVisualFocusItemIndex,\n    triggeredByKeyboard,\n    visualFocusItemIndex\n  ]);\n  const onFocusByMouse = useCallback(() => {\n    triggeredByKeyboard.current = false;\n  }, [triggeredByKeyboard]);\n  useListenFocusTriggers({ ref: focusedElementRef, onFocusByKeyboard, onFocusByMouse });\n\n  return { triggeredByKeyboard };\n}\n\nexport function useKeepFocusOnItemWhenListChanged({\n  visualFocusItemIndex,\n  itemsIds,\n  isItemSelectable,\n  setVisualFocusItemIndex\n}: {\n  visualFocusItemIndex: number;\n  itemsIds: string[];\n  isItemSelectable: (index: number) => boolean;\n  setVisualFocusItemIndex: (index: number) => void;\n}) {\n  const prevItemIds = usePrevious(itemsIds);\n\n  // When item list changed, keep the focus on the same item\n  useEffect(() => {\n    // When the list is changing the index of the focused item is point to a different item then before and\n    // this is why we want to search for the new index of the item and change the index to point to it.\n    let overrideIndexAfterListChanged;\n    const isListChanged = prevItemIds !== undefined && prevItemIds !== itemsIds;\n    if (isListChanged && prevItemIds !== undefined && visualFocusItemIndex !== -1) {\n      const focusedItemId = prevItemIds[visualFocusItemIndex];\n      overrideIndexAfterListChanged = itemsIds.indexOf(focusedItemId);\n    } else {\n      overrideIndexAfterListChanged = visualFocusItemIndex;\n    }\n\n    if (overrideIndexAfterListChanged !== visualFocusItemIndex) {\n      if (isItemSelectable(overrideIndexAfterListChanged)) {\n        setVisualFocusItemIndex(overrideIndexAfterListChanged);\n      } else {\n        const closestSelectableIndex = getNextSelectableIndex({\n          isItemSelectable,\n          visualFocusItemIndex: overrideIndexAfterListChanged,\n          itemsCount: itemsIds.length\n        });\n        setVisualFocusItemIndex(closestSelectableIndex);\n      }\n    }\n  }, [visualFocusItemIndex, itemsIds, isItemSelectable, setVisualFocusItemIndex, prevItemIds]);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}