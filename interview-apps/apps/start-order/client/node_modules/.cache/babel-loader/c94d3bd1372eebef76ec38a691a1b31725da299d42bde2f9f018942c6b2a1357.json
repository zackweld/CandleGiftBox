{"ast":null,"code":"const {\n  MONDAY_API_URL,\n  MONDAY_OAUTH_TOKEN_URL\n} = require(\"./../constants.js\");\nconst fetch = require(\"./fetch\");\nconst COULD_NOT_PARSE_JSON_RESPONSE_ERROR = \"Could not parse JSON from monday.com's GraphQL API response\";\nconst TOKEN_IS_REQUIRED_ERROR = \"Token is required\";\nconst API_TIMEOUT_ERROR = \"Received timeout from monday.com's GraphQL API\";\nfunction apiRequest(url, data, token) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return fetch.nodeFetch(url, {\n    method: options.method || \"POST\",\n    body: JSON.stringify(data || {}),\n    headers: {\n      Authorization: token,\n      \"Content-Type\": \"application/json\",\n      ...(options.apiVersion ? {\n        \"API-Version\": options.apiVersion\n      } : {})\n    }\n  });\n}\nasync function execute(data, token) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!token && options.url !== MONDAY_OAUTH_TOKEN_URL) throw new Error(TOKEN_IS_REQUIRED_ERROR);\n  const url = options.url || MONDAY_API_URL;\n  const path = options.path || \"\";\n  const fullUrl = \"\".concat(url).concat(path);\n  let response = await apiRequest(fullUrl, data, token, options);\n  const responseStatusCode = response.status;\n  const responseContentType = response.headers.get(\"content-type\");\n  if (!responseContentType || !responseContentType.includes(\"application/json\")) {\n    if (responseStatusCode === 504) {\n      throw new Error(API_TIMEOUT_ERROR);\n    }\n    const responseText = await response.text();\n    throw new Error(responseText);\n  }\n  try {\n    return await response.json();\n  } catch (err) {\n    throw new Error(COULD_NOT_PARSE_JSON_RESPONSE_ERROR);\n  }\n}\nmodule.exports = {\n  execute,\n  COULD_NOT_PARSE_JSON_RESPONSE_ERROR,\n  TOKEN_IS_REQUIRED_ERROR,\n  API_TIMEOUT_ERROR\n};","map":{"version":3,"names":["MONDAY_API_URL","MONDAY_OAUTH_TOKEN_URL","require","fetch","COULD_NOT_PARSE_JSON_RESPONSE_ERROR","TOKEN_IS_REQUIRED_ERROR","API_TIMEOUT_ERROR","apiRequest","url","data","token","options","arguments","length","undefined","nodeFetch","method","body","JSON","stringify","headers","Authorization","apiVersion","execute","Error","path","fullUrl","concat","response","responseStatusCode","status","responseContentType","get","includes","responseText","text","json","err","module","exports"],"sources":["/Users/zacharyweld/Documents/Code/CandleGiftBoxDemo/CandleGiftBox/interview-apps/apps/start-order/client/node_modules/monday-sdk-js/src/monday-api-client/monday-api-client.js"],"sourcesContent":["const { MONDAY_API_URL, MONDAY_OAUTH_TOKEN_URL } = require(\"./../constants.js\");\nconst fetch = require(\"./fetch\");\n\nconst COULD_NOT_PARSE_JSON_RESPONSE_ERROR = \"Could not parse JSON from monday.com's GraphQL API response\";\nconst TOKEN_IS_REQUIRED_ERROR = \"Token is required\";\nconst API_TIMEOUT_ERROR = \"Received timeout from monday.com's GraphQL API\";\n\nfunction apiRequest(url, data, token, options = {}) {\n  return fetch.nodeFetch(url, {\n    method: options.method || \"POST\",\n    body: JSON.stringify(data || {}),\n    headers: {\n      Authorization: token,\n      \"Content-Type\": \"application/json\",\n      ...(options.apiVersion ? { \"API-Version\": options.apiVersion } : {})\n    }\n  });\n}\n\nasync function execute(data, token, options = {}) {\n  if (!token && options.url !== MONDAY_OAUTH_TOKEN_URL) throw new Error(TOKEN_IS_REQUIRED_ERROR);\n\n  const url = options.url || MONDAY_API_URL;\n  const path = options.path || \"\";\n  const fullUrl = `${url}${path}`;\n  let response = await apiRequest(fullUrl, data, token, options);\n\n  const responseStatusCode = response.status;\n  const responseContentType = response.headers.get(\"content-type\");\n  if (!responseContentType || !responseContentType.includes(\"application/json\")) {\n    if (responseStatusCode === 504) {\n      throw new Error(API_TIMEOUT_ERROR);\n    }\n\n    const responseText = await response.text();\n    throw new Error(responseText);\n  }\n\n  try {\n    return await response.json();\n  } catch (err) {\n    throw new Error(COULD_NOT_PARSE_JSON_RESPONSE_ERROR);\n  }\n}\n\nmodule.exports = { execute, COULD_NOT_PARSE_JSON_RESPONSE_ERROR, TOKEN_IS_REQUIRED_ERROR, API_TIMEOUT_ERROR };\n"],"mappings":"AAAA,MAAM;EAAEA,cAAc;EAAEC;AAAuB,CAAC,GAAGC,OAAO,CAAC,mBAAmB,CAAC;AAC/E,MAAMC,KAAK,GAAGD,OAAO,CAAC,SAAS,CAAC;AAEhC,MAAME,mCAAmC,GAAG,6DAA6D;AACzG,MAAMC,uBAAuB,GAAG,mBAAmB;AACnD,MAAMC,iBAAiB,GAAG,gDAAgD;AAE1E,SAASC,UAAUA,CAACC,GAAG,EAAEC,IAAI,EAAEC,KAAK,EAAgB;EAAA,IAAdC,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EAChD,OAAOT,KAAK,CAACY,SAAS,CAACP,GAAG,EAAE;IAC1BQ,MAAM,EAAEL,OAAO,CAACK,MAAM,IAAI,MAAM;IAChCC,IAAI,EAAEC,IAAI,CAACC,SAAS,CAACV,IAAI,IAAI,CAAC,CAAC,CAAC;IAChCW,OAAO,EAAE;MACPC,aAAa,EAAEX,KAAK;MACpB,cAAc,EAAE,kBAAkB;MAClC,IAAIC,OAAO,CAACW,UAAU,GAAG;QAAE,aAAa,EAAEX,OAAO,CAACW;MAAW,CAAC,GAAG,CAAC,CAAC;IACrE;EACF,CAAC,CAAC;AACJ;AAEA,eAAeC,OAAOA,CAACd,IAAI,EAAEC,KAAK,EAAgB;EAAA,IAAdC,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EAC9C,IAAI,CAACF,KAAK,IAAIC,OAAO,CAACH,GAAG,KAAKP,sBAAsB,EAAE,MAAM,IAAIuB,KAAK,CAACnB,uBAAuB,CAAC;EAE9F,MAAMG,GAAG,GAAGG,OAAO,CAACH,GAAG,IAAIR,cAAc;EACzC,MAAMyB,IAAI,GAAGd,OAAO,CAACc,IAAI,IAAI,EAAE;EAC/B,MAAMC,OAAO,MAAAC,MAAA,CAAMnB,GAAG,EAAAmB,MAAA,CAAGF,IAAI,CAAE;EAC/B,IAAIG,QAAQ,GAAG,MAAMrB,UAAU,CAACmB,OAAO,EAAEjB,IAAI,EAAEC,KAAK,EAAEC,OAAO,CAAC;EAE9D,MAAMkB,kBAAkB,GAAGD,QAAQ,CAACE,MAAM;EAC1C,MAAMC,mBAAmB,GAAGH,QAAQ,CAACR,OAAO,CAACY,GAAG,CAAC,cAAc,CAAC;EAChE,IAAI,CAACD,mBAAmB,IAAI,CAACA,mBAAmB,CAACE,QAAQ,CAAC,kBAAkB,CAAC,EAAE;IAC7E,IAAIJ,kBAAkB,KAAK,GAAG,EAAE;MAC9B,MAAM,IAAIL,KAAK,CAAClB,iBAAiB,CAAC;IACpC;IAEA,MAAM4B,YAAY,GAAG,MAAMN,QAAQ,CAACO,IAAI,CAAC,CAAC;IAC1C,MAAM,IAAIX,KAAK,CAACU,YAAY,CAAC;EAC/B;EAEA,IAAI;IACF,OAAO,MAAMN,QAAQ,CAACQ,IAAI,CAAC,CAAC;EAC9B,CAAC,CAAC,OAAOC,GAAG,EAAE;IACZ,MAAM,IAAIb,KAAK,CAACpB,mCAAmC,CAAC;EACtD;AACF;AAEAkC,MAAM,CAACC,OAAO,GAAG;EAAEhB,OAAO;EAAEnB,mCAAmC;EAAEC,uBAAuB;EAAEC;AAAkB,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}